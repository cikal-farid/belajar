# 0. DevOps V4

Kamu benar: **setelah step 13 (GitLab CI Variables) memang belum ada ‚Äúaksi‚Äù yang otomatis jalan kalau kamu belum melakukan ‚Äútrigger‚Äù pipeline** dan belum ada _file deploy K8s + observability_ yang benar-benar lengkap di repo. Jadi wajar kamu merasa ‚Äúkok nggak ada hasil/URL‚Äù.

Di bawah ini aku tulis ulang **runbook dari nol sampai jadi**, urut, pemula-friendly, dan sudah aku lengkapi bagian yang biasanya hilang: **file-file yang wajib ada**, **kapan harus push**, **cara lihat hasil akhirnya (URL)**, **K8s YAML NodePort**, **Loki+Grafana+Promtail**, dan **healthcheck**.

> **Konsep penting (biar nggak bingung):**
>
> 1. **GitLab CI Variables tidak menjalankan apa-apa.** Mereka cuma ‚Äúmenyediakan secret‚Äù.
> 2. Pipeline baru jalan kalau ada **trigger**, paling umum: **push commit ke branch `main`** (atau klik ‚ÄúRun pipeline‚Äù).
> 3. ‚ÄúURL hasil akhir‚Äù baru bisa kamu buka kalau **Edge Nginx** sudah jalan di `vm-docker` dan file **hosts** sudah benar.

***

### 0) Target arsitektur (yang akan jadi ‚Äúhasil akhir‚Äù)

**Host-only network:** `192.168.56.0/24`

| VM        |            IP | Role                                                        |
| --------- | ------------: | ----------------------------------------------------------- |
| vm-docker | 192.168.56.42 | GitLab Runner + Edge Nginx + Staging Compose + Loki+Grafana |
| vm-harbor | 192.168.56.43 | Harbor registry (TLS)                                       |
| vm-k8s    | 192.168.56.44 | Kubernetes control-plane (kubeadm)                          |
| vm-worker | 192.168.56.45 | Kubernetes worker                                           |

**Akses aplikasi:**

* Harbor UI: `https://harbor.local`
* Staging app: `https://staging.local` (edge ‚Üí container compose)
* Prod app: `https://prod.local` (edge ‚Üí NodePort K8s)

***

### 1) Common Step untuk SEMUA VM (wajib)

> Jalankan di: `vm-docker`, `vm-harbor`, `vm-k8s`, `vm-worker`

#### 1.1 Set hostname

```bash
# vm-harbor
sudo hostnamectl set-hostname vm-harbor

# vm-docker
sudo hostnamectl set-hostname vm-docker

# vm-k8s
sudo hostnamectl set-hostname vm-k8s

# vm-worker
sudo hostnamectl set-hostname vm-worker

hostname
```

#### 1.2 Isi `/etc/hosts` (WAJIB)

Di **setiap VM**:

```bash
sudo nano /etc/hosts
```

Tambahkan:

```
192.168.56.42 vm-docker staging.local prod.local
192.168.56.43 vm-harbor harbor.local
192.168.56.44 vm-k8s
192.168.56.45 vm-worker
```

Cek:

```bash
getent hosts harbor.local
getent hosts staging.local
getent hosts prod.local
```

‚úÖ **WAJIB juga di laptop host** (Windows/Mac/Linux) supaya browser kamu bisa buka `harbor.local`, `staging.local`, `prod.local`.

#### 1.3 Update paket & SSH

```bash
sudo apt-get update -y
sudo apt-get install -y ca-certificates curl git nano openssh-client openssh-server
sudo systemctl enable --now ssh
sudo systemctl status ssh --no-pager
```

#### 1.4 UFW jangan putus SSH (fix kasus scp timeout)

```bash
sudo apt-get install -y ufw
sudo ufw allow OpenSSH
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
sudo ufw enable
sudo ufw status
```

***

### 2) Install Docker di vm-harbor & vm-docker

#### 2.1 Install Docker (vm-harbor dan vm-docker)

Jalankan di **vm-harbor** dan **vm-docker**:

```bash
curl -fsSL https://get.docker.com | sudo sh
sudo usermod -aG docker $USER
newgrp docker

docker version
docker compose version
```

***

### 3) Install Harbor (vm-harbor) + TLS (fix error ‚ÄúPlease specify hostname‚Äù)

> Harbor memang **mewajibkan `hostname`** di `harbor.yml` dan **tidak boleh** localhost/127.0.0.1/0.0.0.0. ([goharbor.io](https://goharbor.io/docs/2.3.0/install-config/configure-yml-file/?utm_source=chatgpt.com))

#### 3.1 Download installer Harbor

```bash
export HARBOR_VERSION="v2.14.1"

cd /tmp
wget -O "harbor-offline-installer-${HARBOR_VERSION}.tgz" \
  "https://github.com/goharbor/harbor/releases/download/${HARBOR_VERSION}/harbor-offline-installer-${HARBOR_VERSION}.tgz"

tar -xzf "harbor-offline-installer-${HARBOR_VERSION}.tgz"
sudo rm -rf /opt/harbor
sudo mv harbor /opt/harbor
sudo chown -R $USER:$USER /opt/harbor
ls -la /opt/harbor
```

#### 3.2 Buat CA + cert `harbor.local`

```bash
sudo apt-get install -y openssl
sudo mkdir -p /etc/harbor/certs
cd /etc/harbor/certs

# CA
sudo openssl genrsa -out ca.key 4096
sudo openssl req -x509 -new -nodes -sha512 -days 3650 \
  -subj "/C=ID/ST=Jakarta/L=Jakarta/O=Lab/OU=DevOps/CN=lab-ca" \
  -key ca.key -out ca.crt

# harbor.local key + csr
sudo openssl genrsa -out harbor.local.key 4096
sudo openssl req -new -sha512 \
  -subj "/C=ID/ST=Jakarta/L=Jakarta/O=Lab/OU=DevOps/CN=harbor.local" \
  -key harbor.local.key -out harbor.local.csr

# SAN
cat | sudo tee v3.harbor.ext >/dev/null <<'EOF'
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
DNS.1=harbor.local
IP.1=192.168.56.43
EOF

sudo openssl x509 -req -sha512 -days 3650 \
  -in harbor.local.csr \
  -CA ca.crt -CAkey ca.key -CAcreateserial \
  -out harbor.local.crt \
  -extfile v3.harbor.ext

openssl x509 -in harbor.local.crt -noout -subject -issuer
```

#### 3.3 Konfigurasi `harbor.yml` (bagian wajib)

```bash
cd /opt/harbor
cp harbor.yml.tmpl harbor.yml
nano harbor.yml
```

Isi minimal:

```yaml
hostname: harbor.local

http:
  port: 80

https:
  port: 443
  certificate: /etc/harbor/certs/harbor.local.crt
  private_key: /etc/harbor/certs/harbor.local.key

harbor_admin_password: Harbor12345
data_volume: /data/harbor
```

Buat data dir:

```bash
sudo mkdir -p /data/harbor
sudo chown -R $USER:$USER /data/harbor
```

#### 3.4 Install & cek Harbor

```bash
cd /opt/harbor
sudo ./install.sh

sudo docker compose -f /opt/harbor/docker-compose.yml ps
curl -k https://harbor.local/
```

‚úÖ Buka di browser laptop: `https://harbor.local`\
Login: `admin / Harbor12345`

#### 3.5 Buat Project `threebody` (di UI Harbor)

Projects ‚Üí New Project ‚Üí `threebody`

***

### 4) Trust CA Harbor di vm-docker (biar docker login/pull aman)

Docker client percaya registry TLS custom dengan taruh CA di `/etc/docker/certs.d/<host>/ca.crt`. ([Docker Documentation](https://docs.docker.com/engine/security/certificates/?utm_source=chatgpt.com))

#### 4.1 Copy CA dari vm-harbor ke vm-docker

Di **vm-docker**:

```bash
scp cikal@192.168.56.43:/etc/harbor/certs/ca.crt /tmp/harbor-ca.crt
```

#### 4.2 Install CA ke Docker (vm-docker)

```bash
sudo mkdir -p /etc/docker/certs.d/harbor.local
sudo cp /tmp/harbor-ca.crt /etc/docker/certs.d/harbor.local/ca.crt
sudo systemctl restart docker

docker login harbor.local
```

***

### 5) Kubernetes (kubeadm) di vm-k8s + vm-worker

> Kamu sudah punya bagian ini, tapi aku rapikan checkpoint-nya.

#### 5.1 Disable swap (dua node)

Di **vm-k8s** dan **vm-worker**:

```bash
sudo swapoff -a
sudo sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
```

#### 5.2 Install containerd (dua node)

```bash
sudo apt-get update -y
sudo apt-get install -y containerd

sudo mkdir -p /etc/containerd
containerd config default | sudo tee /etc/containerd/config.toml >/dev/null
sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/' /etc/containerd/config.toml

sudo systemctl enable --now containerd
sudo systemctl restart containerd
```

#### 5.3 Install kubeadm/kubelet/kubectl (dua node)

> Ikuti repo resmi Kubernetes (cara bisa berubah), tapi intinya: install `kubelet kubeadm kubectl` dan hold.

#### 5.4 Init cluster (hanya vm-k8s)

```bash
cat <<'EOF' | sudo tee /etc/modules-load.d/k8s.conf >/dev/null
overlay
br_netfilter
EOF

sudo modprobe overlay
sudo modprobe br_netfilter

cat <<'EOF' | sudo tee /etc/sysctl.d/99-kubernetes.conf >/dev/null
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF
sudo sysctl --system
```

Init:

```bash
sudo kubeadm init \
  --apiserver-advertise-address=192.168.56.44 \
  --apiserver-cert-extra-sans=192.168.56.44,vm-k8s \
  --pod-network-cidr=192.168.0.0/16
```

Setup kubectl:

```bash
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
kubectl get nodes
```

Install CNI (contoh Calico):

```bash
kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.28.0/manifests/calico.yaml
watch -n 2 -d 'kubectl get nodes'
```

Join worker:

* Ambil join command:

```bash
kubeadm token create --print-join-command --ttl 24h
```

* Jalankan hasilnya di **vm-worker**.

***

### 6) Trust CA Harbor di K8s nodes (containerd)

Containerd mendukung `config_path="/etc/containerd/certs.d"` + `hosts.toml`. ([GitHub](https://github.com/containerd/containerd/blob/main/docs/hosts.md?utm_source=chatgpt.com))

> Jalankan di **vm-k8s** dan **vm-worker**

#### 6.1 Copy CA

```bash
scp cikal@192.168.56.43:/etc/harbor/certs/ca.crt /tmp/harbor-ca.crt
```

#### 6.2 Buat hosts.toml

```bash
sudo mkdir -p /etc/containerd/certs.d/harbor.local
sudo cp /tmp/harbor-ca.crt /etc/containerd/certs.d/harbor.local/ca.crt

cat | sudo tee /etc/containerd/certs.d/harbor.local/hosts.toml >/dev/null <<'EOF'
server = "https://harbor.local"

[host."https://harbor.local"]
  ca = "/etc/containerd/certs.d/harbor.local/ca.crt"
EOF
```

#### 6.3 Aktifkan config\_path di containerd

```bash
sudo nano /etc/containerd/config.toml
```

Pastikan ada:

```toml
[plugins."io.containerd.grpc.v1.cri".registry]
  config_path = "/etc/containerd/certs.d"
```

Restart:

```bash
sudo systemctl restart containerd
```

***

### 7) GitHub ‚Üí GitLab (trigger pipeline butuh push)

#### 7.1 (vm-docker) SSH key GitLab (kalau belum)

```bash
ssh-keygen -t ed25519 -C "vm-docker-gitlab" -f ~/.ssh/id_ed25519 -N ""
cat ~/.ssh/id_ed25519.pub
```

Config altssh port 443:

```bash
mkdir -p ~/.ssh
nano ~/.ssh/config
```

Isi:

```sshconfig
Host gitlab-443
  HostName altssh.gitlab.com
  User git
  Port 443
```

Permission:

```bash
chmod 700 ~/.ssh
chmod 600 ~/.ssh/config
```

Upload public key ke GitLab ‚Üí Profile ‚Üí SSH Keys.

Test:

```bash
ssh -T git@gitlab-443
```

#### 7.2 Clone GitHub repo & push ke GitLab

```bash
cd ~
git clone https://github.com/cikal-farid/three-body-problem-main.git
cd three-body-problem-main
```

Tambah remote GitLab:

```bash
git remote add gitlab git@gitlab.com:USERNAME/three-body-problem-main.git
git branch -M main
git push -u gitlab main
```

‚úÖ Sampai sini **belum ada CI/CD** kalau `.gitlab-ci.yml` belum dibuat.

***

### 8) Tambahkan file WAJIB di repo (ini yang bikin ‚Äúada hasil‚Äù)

Di **vm-docker** dalam repo:

```bash
cd ~/three-body-problem-main
mkdir -p deploy/edge/nginx/conf.d
mkdir -p deploy/edge/certs
mkdir -p deploy/staging
mkdir -p deploy/k8s/base
mkdir -p deploy/observability
```

#### 8.1 Dockerfile multistage

**go/Dockerfile**

```dockerfile
FROM golang:1.22 AS builder
WORKDIR /app
COPY . .
RUN go mod download
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o server .

FROM gcr.io/distroless/static:nonroot
WORKDIR /
COPY --from=builder /app/server /server
USER nonroot:nonroot
EXPOSE 8080
ENTRYPOINT ["/server"]
```

**laravel/Dockerfile**

```dockerfile
FROM composer:2 AS vendor
WORKDIR /app
COPY . .
RUN composer install --no-dev --optimize-autoloader

FROM php:8.2-apache
WORKDIR /var/www/html
RUN a2enmod rewrite
COPY . .
COPY --from=vendor /app/vendor ./vendor
RUN chown -R www-data:www-data storage bootstrap/cache || true
EXPOSE 80
CMD ["apache2-foreground"]
```

**frontend/Dockerfile**

```dockerfile
FROM node:20 AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .

ARG REACT_APP_GO_API_BASE=/go
ARG REACT_APP_LARAVEL_API_BASE=/laravel
ENV REACT_APP_GO_API_BASE=$REACT_APP_GO_API_BASE
ENV REACT_APP_LARAVEL_API_BASE=$REACT_APP_LARAVEL_API_BASE
RUN npm run build

FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html
EXPOSE 80
```

#### 8.2 Edge Nginx (HTTPS + rate limiting)

NGINX rate limit pakai `limit_req_zone` dan `limit_req`. ([Nginx](https://nginx.org/en/docs/http/ngx_http_limit_req_module.html?utm_source=chatgpt.com))

**deploy/edge/nginx/conf.d/edge.conf**

```nginx
limit_req_zone $binary_remote_addr zone=api_rl:10m rate=5r/s;

server {
  listen 80;
  server_name staging.local prod.local;
  return 301 https://$host$request_uri;
}

# ---- STAGING (docker compose) ----
server {
  listen 443 ssl;
  server_name staging.local;

  ssl_certificate     /etc/nginx/certs/tls.crt;
  ssl_certificate_key /etc/nginx/certs/tls.key;

  location / {
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_pass http://stg-frontend:80;
  }

  location /go/ {
    limit_req zone=api_rl burst=10 nodelay;
    proxy_pass http://stg-go:8080/;
  }

  location /laravel/ {
    limit_req zone=api_rl burst=10 nodelay;
    proxy_pass http://stg-laravel:80/;
  }
}

# ---- PROD (K8s NodePort) ----
server {
  listen 443 ssl;
  server_name prod.local;

  ssl_certificate     /etc/nginx/certs/tls.crt;
  ssl_certificate_key /etc/nginx/certs/tls.key;

  location / {
    proxy_pass http://192.168.56.45:30080;
  }

  location /go/ {
    limit_req zone=api_rl burst=10 nodelay;
    proxy_pass http://192.168.56.45:30081/;
  }

  location /laravel/ {
    limit_req zone=api_rl burst=10 nodelay;
    proxy_pass http://192.168.56.45:30082/;
  }
}
```

**deploy/edge/docker-compose.edge.yml**

```yaml
services:
  edge-nginx:
    image: nginx:alpine
    container_name: edge-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d:ro
      - ./certs:/etc/nginx/certs:ro
    networks:
      - edge-net
    restart: unless-stopped

networks:
  edge-net:
    name: edge-net
```

> üîê **Penting:** jangan commit `tls.key` ke repo. Kita akan taruh cert/key dari **GitLab Variables (File)** saat deploy.

#### 8.3 Staging Docker Compose

**deploy/staging/docker-compose.staging.yml**

```yaml
services:
  stg-mysql:
    image: mysql:8.0
    container_name: stg-mysql
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    volumes:
      - stg_mysql_data:/var/lib/mysql
    networks: [edge-net]
    healthcheck:
      test: ["CMD-SHELL", "MYSQL_PWD=$$MYSQL_ROOT_PASSWORD mysqladmin ping -h 127.0.0.1 --protocol=tcp -uroot --silent"]
      interval: 5s
      timeout: 5s
      retries: 40

  stg-go:
    image: ${REGISTRY}/go:${TAG}
    container_name: stg-go
    environment:
      DB_HOST: stg-mysql
      DB_PORT: "3306"
      DB_NAME: ${MYSQL_DATABASE}
      DB_USER: ${MYSQL_USER}
      DB_PASS: ${MYSQL_PASSWORD}
    networks: [edge-net]
    depends_on:
      stg-mysql:
        condition: service_healthy

  stg-laravel:
    image: ${REGISTRY}/laravel:${TAG}
    container_name: stg-laravel
    environment:
      DB_HOST: stg-mysql
      DB_PORT: "3306"
      DB_DATABASE: ${MYSQL_DATABASE}
      DB_USERNAME: ${MYSQL_USER}
      DB_PASSWORD: ${MYSQL_PASSWORD}
      APP_KEY: ${LARAVEL_APP_KEY}
      APP_ENV: production
      APP_DEBUG: "false"
    networks: [edge-net]
    depends_on:
      stg-mysql:
        condition: service_healthy

  stg-frontend:
    image: ${REGISTRY}/frontend:${TAG}
    container_name: stg-frontend
    networks: [edge-net]
    depends_on:
      - stg-go
      - stg-laravel

volumes:
  stg_mysql_data:

networks:
  edge-net:
    external: true
```

***

### 9) K8s YAML PROD (NodePort) ‚Äî ini yang sebelumnya ‚Äúkosong‚Äù

Buat file-file berikut:

#### 9.1 Namespace

**deploy/k8s/base/00-namespace.yaml**

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: threebody-prod
```

#### 9.2 MySQL (hostPath, pin ke worker)

> Jalankan ini **sekali** di `vm-worker` supaya folder ada:

```bash
sudo mkdir -p /data/threebody/mysql
sudo chmod 777 /data/threebody/mysql
```

**deploy/k8s/base/10-mysql.yaml**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
  namespace: threebody-prod
spec:
  selector:
    app: mysql
  ports:
    - name: mysql
      port: 3306
      targetPort: 3306
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
  namespace: threebody-prod
spec:
  serviceName: mysql
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      nodeSelector:
        kubernetes.io/hostname: vm-worker
      containers:
        - name: mysql
          image: mysql:8.0
          ports:
            - containerPort: 3306
          env:
            - name: MYSQL_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: MYSQL_ROOT_PASSWORD
            - name: MYSQL_DATABASE
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: MYSQL_DATABASE
            - name: MYSQL_USER
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: MYSQL_USER
            - name: MYSQL_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: MYSQL_PASSWORD
          volumeMounts:
            - name: mysql-data
              mountPath: /var/lib/mysql
  volumeClaimTemplates: []
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: mysql-pv-hostpath
spec:
  capacity:
    storage: 5Gi
  accessModes: ["ReadWriteOnce"]
  persistentVolumeReclaimPolicy: Retain
  hostPath:
    path: /data/threebody/mysql
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-data
  namespace: threebody-prod
spec:
  accessModes: ["ReadWriteOnce"]
  resources:
    requests:
      storage: 5Gi
  volumeName: mysql-pv-hostpath
```

> Catatan: HostPath ini ‚Äúlab-friendly‚Äù (bukan best practice cloud), tapi cukup untuk tugas.

#### 9.3 GO (NodePort 30081)

**deploy/k8s/base/20-go.yaml**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: go
  namespace: threebody-prod
spec:
  type: NodePort
  selector:
    app: go
  ports:
    - name: http
      port: 8080
      targetPort: 8080
      nodePort: 30081
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: go
  namespace: threebody-prod
spec:
  replicas: 1
  selector:
    matchLabels:
      app: go
  template:
    metadata:
      labels:
        app: go
    spec:
      imagePullSecrets:
        - name: harbor-pull
      containers:
        - name: go
          image: harbor.local/threebody/go:latest
          ports:
            - containerPort: 8080
          env:
            - name: DB_HOST
              value: mysql
            - name: DB_PORT
              value: "3306"
            - name: DB_NAME
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: MYSQL_DATABASE
            - name: DB_USER
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: MYSQL_USER
            - name: DB_PASS
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: MYSQL_PASSWORD
          readinessProbe:
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 5
          livenessProbe:
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 20
            periodSeconds: 10
```

> Kalau service Go kamu **tidak punya endpoint `/health`**, ganti probe ke path yang ada (atau hapus probe dulu biar gampang).

#### 9.4 Laravel (NodePort 30082)

**deploy/k8s/base/30-laravel.yaml**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: laravel
  namespace: threebody-prod
spec:
  type: NodePort
  selector:
    app: laravel
  ports:
    - name: http
      port: 80
      targetPort: 80
      nodePort: 30082
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: laravel
  namespace: threebody-prod
spec:
  replicas: 1
  selector:
    matchLabels:
      app: laravel
  template:
    metadata:
      labels:
        app: laravel
    spec:
      imagePullSecrets:
        - name: harbor-pull
      containers:
        - name: laravel
          image: harbor.local/threebody/laravel:latest
          ports:
            - containerPort: 80
          env:
            - name: DB_HOST
              value: mysql
            - name: DB_PORT
              value: "3306"
            - name: DB_DATABASE
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: MYSQL_DATABASE
            - name: DB_USERNAME
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: MYSQL_USER
            - name: DB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: MYSQL_PASSWORD
            - name: APP_KEY
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: LARAVEL_APP_KEY
            - name: APP_ENV
              value: production
            - name: APP_DEBUG
              value: "false"
```

#### 9.5 Frontend (NodePort 30080)

**deploy/k8s/base/40-frontend.yaml**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: frontend
  namespace: threebody-prod
spec:
  type: NodePort
  selector:
    app: frontend
  ports:
    - name: http
      port: 80
      targetPort: 80
      nodePort: 30080
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: threebody-prod
spec:
  replicas: 1
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      imagePullSecrets:
        - name: harbor-pull
      containers:
        - name: frontend
          image: harbor.local/threebody/frontend:latest
          ports:
            - containerPort: 80
```

***

### 10) Install GitLab Runner di vm-docker + bikin runner bisa docker build

#### 10.1 Install runner

```bash
sudo apt-get update -y
sudo apt-get install -y curl ca-certificates
curl -L "https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh" | sudo bash
sudo apt-get install -y gitlab-runner
gitlab-runner --version
sudo systemctl status gitlab-runner --no-pager
```

#### 10.2 Penting: user `gitlab-runner` harus bisa akses docker

```bash
sudo usermod -aG docker gitlab-runner
sudo systemctl restart gitlab-runner
```

Cek cepat:

```bash
sudo -u gitlab-runner docker ps
```

Kalau ini error, pipeline build juga error.

#### 10.3 Register runner (Shell executor, tag deploy)

```bash
sudo gitlab-runner register
```

Isi:

* URL: `https://gitlab.com` (atau domain GitLab kamu)
* Token: dari UI project
* Executor: `shell`
* Tags: `deploy`

***

### 11) Buat GitLab CI Variables (Secret Manager)

> Ini step 13 kamu ‚Äî **benar**, tapi setelah ini kamu harus **push commit** untuk trigger.

Di GitLab ‚Üí Project ‚Üí Settings ‚Üí CI/CD ‚Üí Variables:

**String variables:**

* `HARBOR_USERNAME` = `admin`
* `HARBOR_PASSWORD` = `Harbor12345`
* `MYSQL_ROOT_PASSWORD` = ...
* `MYSQL_DATABASE` = `threebody`
* `MYSQL_USER` = ...
* `MYSQL_PASSWORD` = ...
* `LARAVEL_APP_KEY` = `base64:...`
* `KUBECONFIG_B64` = base64 kubeconfig

Generate laravel app key (di mana saja):

```bash
echo "base64:$(openssl rand -base64 32)"
```

Generate `KUBECONFIG_B64` (di **vm-k8s**):

```bash
base64 -w0 ~/.kube/config > /tmp/kubeconfig.b64
wc -c /tmp/kubeconfig.b64
head -c 60 /tmp/kubeconfig.b64; echo
```

**File variables (lebih aman) untuk TLS edge:**

* `EDGE_TLS_CRT` (Type: File) ‚Üí isi file cert
* `EDGE_TLS_KEY` (Type: File) ‚Üí isi file key

> Kamu bisa generate cert `staging.local/prod.local` pakai CA yang sama di vm-harbor (seperti yang kamu tulis sebelumnya), tapi **jangan commit private key**.

***

### 12) .gitlab-ci.yml (ini yang menghubungkan semuanya)

Buat/replace `.gitlab-ci.yml` di root repo:

```yaml
stages:
  - build
  - deploy_staging
  - deploy_prod

variables:
  DOCKER_BUILDKIT: "1"
  TAG: "$CI_COMMIT_SHORT_SHA"
  REGISTRY: "harbor.local/threebody"

default:
  tags: ["deploy"]
  before_script:
    - set -euo pipefail

build_images:
  stage: build
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  script:
    - echo "$HARBOR_PASSWORD" | docker login harbor.local -u "$HARBOR_USERNAME" --password-stdin
    - docker build -t "$REGISTRY/frontend:$TAG" -f frontend/Dockerfile frontend
    - docker build -t "$REGISTRY/go:$TAG" -f go/Dockerfile go
    - docker build -t "$REGISTRY/laravel:$TAG" -f laravel/Dockerfile laravel
    - docker push "$REGISTRY/frontend:$TAG"
    - docker push "$REGISTRY/go:$TAG"
    - docker push "$REGISTRY/laravel:$TAG"

deploy_staging:
  stage: deploy_staging
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  script:
    - echo "$HARBOR_PASSWORD" | docker login harbor.local -u "$HARBOR_USERNAME" --password-stdin

    # tulis TLS edge dari File variable (JANGAN commit key)
    - mkdir -p deploy/edge/certs
    - cp "$EDGE_TLS_CRT" deploy/edge/certs/tls.crt
    - cp "$EDGE_TLS_KEY" deploy/edge/certs/tls.key

    # start edge network + nginx (idempotent)
    - cd deploy/edge
    - docker compose -f docker-compose.edge.yml up -d
    - cd ../..

    # deploy staging
    - cd deploy/staging
    - export REGISTRY="$REGISTRY"
    - export TAG="$TAG"
    - docker compose -f docker-compose.staging.yml up -d
    - cd ../..

    # basic healthcheck
    - curl -kfsS https://staging.local/ || (docker ps && exit 1)

deploy_prod:
  stage: deploy_prod
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  script:
    # kubeconfig from CI var
    - echo "$KUBECONFIG_B64" | base64 -d > /tmp/kubeconfig
    - export KUBECONFIG=/tmp/kubeconfig

    # create/update secrets (from GitLab variables)
    - kubectl apply -f deploy/k8s/base/00-namespace.yaml

    - kubectl -n threebody-prod create secret docker-registry harbor-pull \
        --docker-server=harbor.local \
        --docker-username="$HARBOR_USERNAME" \
        --docker-password="$HARBOR_PASSWORD" \
        --dry-run=client -o yaml | kubectl apply -f -

    - kubectl -n threebody-prod create secret generic app-secrets \
        --from-literal=MYSQL_ROOT_PASSWORD="$MYSQL_ROOT_PASSWORD" \
        --from-literal=MYSQL_DATABASE="$MYSQL_DATABASE" \
        --from-literal=MYSQL_USER="$MYSQL_USER" \
        --from-literal=MYSQL_PASSWORD="$MYSQL_PASSWORD" \
        --from-literal=LARAVEL_APP_KEY="$LARAVEL_APP_KEY" \
        --dry-run=client -o yaml | kubectl apply -f -

    # apply workloads/services
    - kubectl apply -f deploy/k8s/base/

    # set images to current TAG
    - kubectl -n threebody-prod set image deploy/frontend frontend="$REGISTRY/frontend:$TAG"
    - kubectl -n threebody-prod set image deploy/go go="$REGISTRY/go:$TAG"
    - kubectl -n threebody-prod set image deploy/laravel laravel="$REGISTRY/laravel:$TAG"

    # wait rollout
    - kubectl -n threebody-prod rollout status deploy/frontend --timeout=180s
    - kubectl -n threebody-prod rollout status deploy/go --timeout=180s
    - kubectl -n threebody-prod rollout status deploy/laravel --timeout=180s

    # prod healthcheck via edge
    - curl -kfsS https://prod.local/ || exit 1
```

***

### 13) LANGKAH YANG KAMU TANYA: ‚Äúsetelah variables, harus push lagi?‚Äù

‚úÖ **YA.** Minimal kamu harus melakukan **commit & push** yang berisi:

* `.gitlab-ci.yml`
* Dockerfile semua service
* `deploy/edge/*`
* `deploy/staging/*`
* `deploy/k8s/base/*`

Kalau file-file itu sudah ada tapi pipeline belum jalan, lakukan ‚Äúempty commit‚Äù:

```bash
cd ~/three-body-problem-main
git add .
git commit -m "ci: add pipeline + deploy manifests"
git push gitlab main
```

Kalau kamu sudah commit sebelumnya tapi mau trigger ulang:

```bash
git commit --allow-empty -m "chore: trigger pipeline"
git push gitlab main
```

***

### 14) Cara melihat ‚Äúhasil akhirnya‚Äù (URL) + checklist

#### 14.1 Cek pipeline di GitLab

GitLab ‚Üí Build ‚Üí Pipelines\
Pastikan:

* Runner status ‚Äúonline‚Äù
* Job `build_images` sukses ‚Üí images muncul di Harbor project `threebody`
* Job `deploy_staging` sukses
* Job `deploy_prod` sukses

#### 14.2 Cek di vm-docker (edge + staging container)

```bash
docker ps
curl -kI https://staging.local/
```

#### 14.3 Cek di K8s (prod)

Di vm-k8s:

```bash
kubectl -n threebody-prod get all -o wide
kubectl -n threebody-prod get svc
```

#### 14.4 URL yang harus bisa dibuka dari laptop

* `https://harbor.local`
* `https://staging.local`
* `https://prod.local`

> Kalau browser warning TLS (karena CA lab), itu normal. Solusi rapi: import `ca.crt` ke trust store OS laptop.

***

### 15) Observability (Loki + Grafana + Promtail) ‚Äî versi sederhana tapi jalan

Kalau kamu mau cepat, taruh Loki+Grafana di **vm-docker** pakai compose.

#### 15.1 Compose Loki+Grafana+Promtail (vm-docker)

**deploy/observability/docker-compose.observability.yml**

```yaml
services:
  loki:
    image: grafana/loki:2.9.8
    command: -config.file=/etc/loki/config.yml
    volumes:
      - ./loki-config.yml:/etc/loki/config.yml:ro
    ports:
      - "3100:3100"
    restart: unless-stopped

  grafana:
    image: grafana/grafana:10.4.5
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=admin
    restart: unless-stopped

  promtail-docker:
    image: grafana/promtail:2.9.8
    command: -config.file=/etc/promtail/config.yml
    volumes:
      - ./promtail-docker.yml:/etc/promtail/config.yml:ro
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - /var/log:/var/log:ro
    restart: unless-stopped
```

**deploy/observability/loki-config.yml**

```yaml
auth_enabled: false
server:
  http_listen_port: 3100

common:
  path_prefix: /tmp/loki
  storage:
    filesystem:
      chunks_directory: /tmp/loki/chunks
      rules_directory: /tmp/loki/rules
  replication_factor: 1
  ring:
    kvstore:
      store: inmemory

schema_config:
  configs:
    - from: 2024-01-01
      store: boltdb-shipper
      object_store: filesystem
      schema: v12
      index:
        prefix: index_
        period: 24h
```

**deploy/observability/promtail-docker.yml**

```yaml
server:
  http_listen_port: 9080
  grpc_listen_port: 0

positions:
  filename: /tmp/positions.yaml

clients:
  - url: http://loki:3100/loki/api/v1/push

scrape_configs:
  - job_name: docker
    static_configs:
      - targets: [localhost]
        labels:
          job: docker
          __path__: /var/lib/docker/containers/*/*.log
```

Jalankan (vm-docker):

```bash
cd ~/three-body-problem-main/deploy/observability
docker compose -f docker-compose.observability.yml up -d
```

Buka Grafana:

* `http://192.168.56.42:3000` (atau lewat hosts kalau kamu mau)
* Login `admin/admin`
* Add datasource Loki: URL `http://loki:3100`

> Kalau kamu butuh promtail di K8s juga (DaemonSet) biar log pods masuk Loki, bilang aja‚Äîaku bisa tuliskan YAML DaemonSet promtail yang push ke `http://192.168.56.42:3100`.

***

## Ringkas jawaban untuk kebingungan kamu

* **Setelah step 13 (Variables), kamu harus melakukan `commit + push` ke GitLab** (atau run pipeline manual).
* Pipeline akan:
  1. build & push image ke Harbor
  2. deploy staging (Compose) + jalankan Edge Nginx
  3. deploy prod (K8s NodePort) + healthcheck
* **Hasil akhirnya dibuka dari laptop** lewat:
  * `https://staging.local`
  * `https://prod.local`
  * `https://harbor.local`

Kalau kamu mau, kirim **1 screenshot** halaman GitLab Pipelines (atau copy log error job yang gagal). Aku bisa tunjukin tepat di step mana kamu ‚Äústuck‚Äù (runner offline, docker permission, KUBECONFIG salah, image pull gagal, dll) dan kasih perintah fix-nya.
