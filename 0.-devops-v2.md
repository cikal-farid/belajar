# 0. DevOps V2

Berikut runbook yang **rapi, urut, detail, ramah pemula** untuk skenario 4 VM kamu (**NAT + Host-Only**) sampai:

* **Staging** jalan di **VM docker** pakai **Docker Compose**
* **Image multistage** dipush ke **Harbor (HTTPS)**
* **Production** deploy ke **Kubernetes kubeadm (bukan k3s)** di VM 44+45
* **Tanpa Ingress** (kita pakai **NodePort + Nginx reverse-proxy** untuk **HTTPS + rate limiting**)
* **Logging terpusat** ke **Loki + Grafana**
* **Secrets** pakai **GitLab CI/CD Variables**
* Plus **dokumen Sistem Design DRC** (tinggal copy ke README)

> Catatan: Kubernetes repo & langkah install kubeadm sekarang pakai **pkgs.k8s.io** (repo legacy sudah deprecated). ([Kubernetes](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/))

***

### 0) Gambaran Arsitektur Target

**Host-Only network:** `192.168.56.0/24` (VirtualBox vboxnet0)

| VM            |    IP Host-Only | Role                                   |
| ------------- | --------------: | -------------------------------------- |
| VM docker     | `192.168.56.42` | Staging Docker Compose + GitLab Runner |
| VM harbor     | `192.168.56.43` | Harbor Registry (HTTPS self-signed)    |
| VM kubernetes | `192.168.56.44` | Control-plane kubeadm                  |
| VM worker     | `192.168.56.45` | Worker kubeadm                         |

**Port aplikasi (sesuai repo):**

* React: **3000**
* Laravel API: **8001**
* Go API: **8080**

**Flow CI/CD:**\
GitLab push → test → build image multistage → push Harbor → deploy staging (compose) + healthcheck → deploy prod (k8s) + rollout/healthcheck → logs semua masuk Loki → Grafana.

***

### 1) Setup Host-Only Network (Laptop/Host)

**VirtualBox → File → Host Network Manager**

* Buat `vboxnet0`
* IPv4: `192.168.56.1`
* DHCP: **OFF** (biar static & rapi)

Di **setiap VM**, set:

* Adapter 1: **NAT**
* Adapter 2: **Host-Only** (`vboxnet0`)

***

### 2) Install Ubuntu & Baseline (Semua VM)

Pakai Ubuntu Server 22.04/24.04.

#### 2.1 Set hostname (per VM)

Jalankan sesuai VM:

```bash
sudo hostnamectl set-hostname docker
sudo hostnamectl set-hostname harbor
sudo hostnamectl set-hostname k8s
sudo hostnamectl set-hostname worker
```

#### 2.2 Update paket dasar (semua VM)

```bash
sudo apt-get update
sudo apt-get -y upgrade
sudo apt-get -y install ca-certificates curl gnupg git unzip jq vim net-tools
```

#### 2.3 Matikan swap (K8s nodes saja: VM 44 & 45)

```bash
sudo swapoff -a
sudo sed -i.bak '/\sswap\s/s/^/#/' /etc/fstab
```

***

### 3) IP Static Host-Only (PENTING)

Biasanya:

* NAT: `enp0s3` (DHCP)
* Host-only: `enp0s8` (STATIC)

Cek interface:

```bash
ip a
```

Edit netplan (contoh **VM docker = 192.168.56.42**):

```bash
sudo nano /etc/netplan/01-netcfg.yaml
```

Contoh isi:

```yaml
network:
  version: 2
  ethernets:
    enp0s3:
      dhcp4: true
    enp0s8:
      dhcp4: false
      addresses: [192.168.56.42/24]
      nameservers:
        addresses: [1.1.1.1,8.8.8.8]
```

Ulangi untuk VM lain:

* harbor → `192.168.56.43/24`
* k8s → `192.168.56.44/24`
* worker → `192.168.56.45/24`

Apply:

```bash
sudo netplan apply
```

Tes ping antar VM (contoh dari VM docker):

```bash
ping -c 2 192.168.56.43
ping -c 2 192.168.56.44
ping -c 2 192.168.56.45
```

***

### 4) Set `/etc/hosts` (di SEMUA VM + idealnya di Laptop/Host)

Edit:

```bash
sudo nano /etc/hosts
```

Tambahkan:

```txt
192.168.56.42 docker.local docker
192.168.56.43 harbor.local harbor
192.168.56.44 k8s.local k8s
192.168.56.45 worker.local worker

# endpoint staging & prod (tanpa ingress, nanti diarahkan ke Nginx reverse proxy)
192.168.56.42 staging.local
192.168.56.44 prod.local
```

***

## BAGIAN A — VM HARBOR (192.168.56.43)

### 5) Install Docker (VM harbor)

```bash
sudo apt-get update
sudo apt-get -y install docker.io docker-compose-plugin
sudo systemctl enable --now docker
sudo usermod -aG docker $USER
newgrp docker
docker version
```

***

### 6) Install Harbor dengan HTTPS self-signed

> Harbor resmi menyarankan HTTPS untuk menghindari MITM; self-signed boleh untuk lab/dev. ([Harbor](https://goharbor.io/docs/2.0.0/install-config/configure-https/))

#### 6.1 Download Harbor offline installer

Ambil “harbor-offline-installer-\*.tgz” (via browser/host), lalu copy ke VM harbor (scp).

Contoh:

```bash
cd ~
ls -lah harbor-offline-installer-*.tgz
tar -xzf harbor-offline-installer-*.tgz
cd harbor
```

#### 6.2 Buat sertifikat self-signed untuk `harbor.local`

Bikin folder cert:

```bash
sudo mkdir -p /opt/harbor/certs
cd /opt/harbor/certs
```

Buat CA + server cert (pakai SAN) (sesuai pola Harbor docs) ([Harbor](https://goharbor.io/docs/2.0.0/install-config/configure-https/)):

```bash
# CA
openssl genrsa -out ca.key 4096
openssl req -x509 -new -nodes -sha512 -days 3650 \
  -subj "/C=ID/ST=Jakarta/L=Jakarta/O=Lab/OU=DevOps/CN=harbor.local" \
  -key ca.key -out ca.crt

# Server key
openssl genrsa -out harbor.local.key 4096

# CSR
openssl req -sha512 -new \
  -subj "/C=ID/ST=Jakarta/L=Jakarta/O=Lab/OU=DevOps/CN=harbor.local" \
  -key harbor.local.key -out harbor.local.csr

# v3.ext (SAN)
cat > v3.ext <<'EOF'
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
DNS.1=harbor.local
DNS.2=harbor
IP.1=192.168.56.43
EOF

# Sign cert
openssl x509 -req -sha512 -days 3650 \
  -extfile v3.ext \
  -CA ca.crt -CAkey ca.key -CAcreateserial \
  -in harbor.local.csr -out harbor.local.crt
```

#### 6.3 Configure Harbor pakai cert

Harbor pakai path default `/data/cert`:

```bash
sudo mkdir -p /data/cert
sudo cp /opt/harbor/certs/harbor.local.crt /data/cert/
sudo cp /opt/harbor/certs/harbor.local.key /data/cert/
```

Edit `harbor.yml`:

```bash
cd ~/harbor
cp harbor.yml.tmpl harbor.yml
nano harbor.yml
```

Minimal:

```yaml
hostname: harbor.local

https:
  port: 443
  certificate: /data/cert/harbor.local.crt
  private_key: /data/cert/harbor.local.key

harbor_admin_password: "GANTI_PASSWORD_ADMIN"
data_volume: /data
```

Install:

```bash
sudo ./prepare
sudo ./install.sh
sudo docker compose ps
```

Tes dari VM harbor:

```bash
curl -k https://harbor.local/api/v2.0/health
```

> Dari laptop/host: buka `https://harbor.local` (akan warning self-signed sampai CA di-trust).

***

## BAGIAN B — VM DOCKER (192.168.56.42) — STAGING + RUNNER

### 7) Install Docker + tools (VM docker)

```bash
sudo apt-get update
sudo apt-get -y install docker.io docker-compose-plugin
sudo systemctl enable --now docker
sudo usermod -aG docker $USER
newgrp docker
docker version
docker compose version
```

***

### 8) Trust sertifikat Harbor (wajib untuk push/pull)

Salin CA dari VM harbor:

```bash
scp cikal@harbor.local:/opt/harbor/certs/ca.crt /tmp/harbor-ca.crt
```

Pasang sebagai CA OS:

```bash
sudo cp /tmp/harbor-ca.crt /usr/local/share/ca-certificates/harbor-ca.crt
sudo update-ca-certificates
```

Pasang untuk Docker registry trust:

```bash
sudo mkdir -p /etc/docker/certs.d/harbor.local
sudo cp /tmp/harbor-ca.crt /etc/docker/certs.d/harbor.local/ca.crt
sudo systemctl restart docker
```

Tes login:

```bash
docker login harbor.local
```

***

### 9) Staging: Docker Compose + HTTPS + Rate limiting (tanpa ingress)

**Ide:** staging expose hanya **1 endpoint HTTPS** (`https://staging.local`) lewat **Nginx reverse proxy**:

* `/` → React (3000)
* `/api/laravel/` → Laravel (8001)
* `/api/go/` → Go (8080)

#### 9.1 Buat sertifikat untuk staging.local

Di VM docker:

```bash
sudo mkdir -p /opt/threebody/certs
cd /opt/threebody/certs

openssl genrsa -out staging.local.key 2048
openssl req -x509 -new -nodes -days 3650 \
  -subj "/C=ID/ST=Jakarta/L=Jakarta/O=Lab/OU=DevOps/CN=staging.local" \
  -key staging.local.key -out staging.local.crt
```

#### 9.2 Buat `docker-compose.staging.yml`

Di root repo (atau `/opt/threebody`), contoh minimal (image dari Harbor):

```yaml
services:
  nginx:
    image: nginx:1.25-alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./ops/nginx/staging.conf:/etc/nginx/conf.d/default.conf:ro
      - /opt/threebody/certs:/etc/nginx/certs:ro
    depends_on:
      - frontend
      - laravel
      - go
    networks: [appnet]

  frontend:
    image: harbor.local/threebody/frontend:${TAG}
    environment:
      - PORT=3000
    networks: [appnet]

  laravel:
    image: harbor.local/threebody/laravel:${TAG}
    environment:
      - APP_ENV=staging
      - APP_KEY=${LARAVEL_APP_KEY}
      - DB_HOST=mysql
      - DB_DATABASE=${MYSQL_DATABASE}
      - DB_USERNAME=${MYSQL_USER}
      - DB_PASSWORD=${MYSQL_PASSWORD}
    networks: [appnet]

  go:
    image: harbor.local/threebody/go:${TAG}
    environment:
      - PORT=8080
      - DB_HOST=mysql
      - DB_NAME=${MYSQL_DATABASE}
      - DB_USER=${MYSQL_USER}
      - DB_PASS=${MYSQL_PASSWORD}
    networks: [appnet]

  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    volumes:
      - mysql_data:/var/lib/mysql
    networks: [appnet]
    healthcheck:
      test: ["CMD-SHELL", "MYSQL_PWD=$$MYSQL_ROOT_PASSWORD mysqladmin ping -h 127.0.0.1 --protocol=tcp -uroot --silent"]
      interval: 5s
      timeout: 5s
      retries: 40
      start_period: 20s

networks:
  appnet: {}

volumes:
  mysql_data: {}
```

#### 9.3 Config Nginx staging (HTTPS + rate limit)

Buat `ops/nginx/staging.conf`:

```nginx
# Rate limit: 10 req/s per IP (burst 20)
limit_req_zone $binary_remote_addr zone=api_rate:10m rate=10r/s;

server {
  listen 80;
  server_name staging.local;
  return 301 https://$host$request_uri;
}

server {
  listen 443 ssl;
  server_name staging.local;

  ssl_certificate     /etc/nginx/certs/staging.local.crt;
  ssl_certificate_key /etc/nginx/certs/staging.local.key;

  # Frontend
  location / {
    proxy_pass http://frontend:3000;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-Proto https;
    proxy_set_header X-Forwarded-For $remote_addr;
  }

  # Laravel API
  location /api/laravel/ {
    limit_req zone=api_rate burst=20 nodelay;
    proxy_pass http://laravel:8001/;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-Proto https;
    proxy_set_header X-Forwarded-For $remote_addr;
  }

  # Go API
  location /api/go/ {
    limit_req zone=api_rate burst=20 nodelay;
    proxy_pass http://go:8080/;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-Proto https;
    proxy_set_header X-Forwarded-For $remote_addr;
  }

  location /healthz {
    return 200 "ok\n";
  }
}
```

#### 9.4 Jalankan staging

```bash
export TAG=dev
docker compose -f docker-compose.staging.yml up -d
docker compose -f docker-compose.staging.yml ps
curl -k https://staging.local/healthz
```

***

## BAGIAN C — MULTISTAGE DOCKERFILE (wajib untuk Harbor)

> Ini template aman untuk “image kecil”. Kamu bisa sesuaikan struktur folder repo.

### 10.1 `laravel/Dockerfile` (multistage)

```dockerfile
# ---- build vendor ----
FROM composer:2 AS vendor
WORKDIR /app
COPY laravel/composer.json laravel/composer.lock ./
RUN composer install --no-dev --prefer-dist --no-interaction --no-progress

# ---- runtime ----
FROM php:8.2-apache AS runtime
WORKDIR /var/www/html

# system deps (sesuaikan kalau perlu ext lain)
RUN apt-get update && apt-get install -y \
    libzip-dev unzip \
  && docker-php-ext-install pdo pdo_mysql zip \
  && a2enmod rewrite \
  && rm -rf /var/lib/apt/lists/*

COPY laravel/ ./
COPY --from=vendor /app/vendor ./vendor

RUN chown -R www-data:www-data storage bootstrap/cache || true
EXPOSE 8001
# kalau app kamu memang listen 8001, pastikan Apache/nginx sesuai.
CMD ["apache2-foreground"]
```

### 10.2 `go/Dockerfile`

```dockerfile
FROM golang:1.22 AS build
WORKDIR /src
COPY go/go.mod go/go.sum ./
RUN go mod download
COPY go/ ./
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o /out/app ./...

FROM gcr.io/distroless/static:nonroot
COPY --from=build /out/app /app
EXPOSE 8080
USER nonroot:nonroot
ENTRYPOINT ["/app"]
```

### 10.3 `frontend/Dockerfile`

```dockerfile
FROM node:20-alpine AS build
WORKDIR /app
COPY frontend/package*.json ./
RUN npm ci
COPY frontend/ ./
RUN npm run build

FROM nginx:1.25-alpine
COPY --from=build /app/build /usr/share/nginx/html
EXPOSE 3000
# kalau repo kamu dev-server 3000, ini static site; akses via 80 internal.
CMD ["nginx","-g","daemon off;"]
```

***

## BAGIAN D — KUBERNETES kubeadm (VM 44 + 45), bukan k3s

Kita pakai:

* **containerd** runtime
* **kubeadm** bootstrap
* **CNI** (misal Calico)
* Expose app via **NodePort** (tanpa ingress)

### 11) Persiapan node Kubernetes (JALANKAN DI VM 44 & VM 45)

#### 11.1 Kernel modules + sysctl

```bash
sudo modprobe br_netfilter
sudo tee /etc/modules-load.d/k8s.conf >/dev/null <<EOF
br_netfilter
EOF

sudo tee /etc/sysctl.d/k8s.conf >/dev/null <<EOF
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF
sudo sysctl --system
```

#### 11.2 Install containerd

```bash
sudo apt-get update
sudo apt-get -y install containerd
sudo mkdir -p /etc/containerd
containerd config default | sudo tee /etc/containerd/config.toml >/dev/null
```

Set `SystemdCgroup = true` (wajib sinkron dengan kubelet) ([Kubernetes](https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/configure-cgroup-driver/?utm_source=chatgpt.com)):

```bash
sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/' /etc/containerd/config.toml
sudo systemctl enable --now containerd
sudo systemctl restart containerd
```

#### 11.3 Install kubeadm/kubelet/kubectl (pakai pkgs.k8s.io)

Ikuti pola official docs ([Kubernetes](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/)):

```bash
sudo apt-get update
sudo apt-get install -y apt-transport-https ca-certificates curl gpg
sudo mkdir -p -m 755 /etc/apt/keyrings

# ganti v1.35 jika kamu mau minor lain, tapi samakan di semua node
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.35/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.35/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list

sudo apt-get update
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl
sudo systemctl enable --now kubelet
```

***

### 12) Init control-plane (VM kubernetes 192.168.56.44)

Di VM **k8s**:

```bash
sudo kubeadm init \
  --apiserver-advertise-address=192.168.56.44 \
  --pod-network-cidr=10.244.0.0/16
```

Set kubeconfig untuk user:

```bash
mkdir -p $HOME/.kube
sudo cp /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
kubectl get nodes
```

> kubeadm create-cluster guide: install runtime + kubeadm → init → pasang pod network (CNI). ([Kubernetes](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/))

#### 12.1 Install CNI (contoh Calico)

Untuk cluster lab, Calico umum dipakai. ([Dokumentasi Calico](https://docs.tigera.io/calico/latest/getting-started/kubernetes/self-managed-onprem/onpremises?utm_source=chatgpt.com))\
Contoh cepat (operator + custom resources):

```bash
# operator
kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.31.2/manifests/tigera-operator.yaml

# custom resources default
curl -O https://raw.githubusercontent.com/projectcalico/calico/v3.31.2/manifests/custom-resources.yaml
kubectl apply -f custom-resources.yaml
```

Tunggu node Ready:

```bash
kubectl get nodes -w
```

***

### 13) Join worker (VM worker 192.168.56.45)

Di VM **k8s**, ambil join command:

```bash
kubeadm token create --print-join-command
```

Copy output itu, jalankan di VM **worker** (pakai sudo), contoh:

```bash
sudo kubeadm join 192.168.56.44:6443 --token <...> --discovery-token-ca-cert-hash sha256:<...>
```

Cek dari control-plane:

```bash
kubectl get nodes -o wide
```

***

### 14) Kubernetes bisa pull image dari Harbor HTTPS self-signed

containerd mendukung `certs.d` + `hosts.toml`, dan juga fallback pola cert ala Docker. ([GitHub](https://github.com/containerd/containerd/blob/main/docs/hosts.md?utm_source=chatgpt.com))

#### 14.1 Copy CA Harbor ke node k8s & worker

Dari masing-masing node:

```bash
scp cikal@harbor.local:/opt/harbor/certs/ca.crt /tmp/harbor-ca.crt
sudo mkdir -p /etc/containerd/certs.d/harbor.local
sudo cp /tmp/harbor-ca.crt /etc/containerd/certs.d/harbor.local/ca.crt
```

#### 14.2 Buat `hosts.toml`

```bash
sudo tee /etc/containerd/certs.d/harbor.local/hosts.toml >/dev/null <<EOF
server = "https://harbor.local"

[host."https://harbor.local"]
  capabilities = ["pull", "resolve", "push"]
  ca = "/etc/containerd/certs.d/harbor.local/ca.crt"
EOF
```

Pastikan containerd config menunjuk certs.d (biasanya sudah ada; cek):

```bash
grep -n "certs.d" -n /etc/containerd/config.toml || true
```

Kalau belum ada, set:

```toml
[plugins."io.containerd.grpc.v1.cri".registry]
  config_path = "/etc/containerd/certs.d"
```

Restart containerd:

```bash
sudo systemctl restart containerd
```

***

## BAGIAN E — DEPLOY APP KE KUBERNETES (tanpa ingress)

**Konsep production tanpa ingress:**

* Service internal tetap ClusterIP
* Untuk akses dari luar: NodePort
* HTTPS + rate limit kita handle dengan **Nginx reverse proxy di host VM k8s** (paling simpel & beginner-friendly)

### 15) Namespace + Secrets

```bash
kubectl create namespace threebody
```

Secret DB:

```bash
kubectl -n threebody create secret generic db-secret \
  --from-literal=MYSQL_ROOT_PASSWORD='...' \
  --from-literal=MYSQL_DATABASE='threebody' \
  --from-literal=MYSQL_USER='threebody' \
  --from-literal=MYSQL_PASSWORD='...'
```

Secret Laravel APP\_KEY:

```bash
kubectl -n threebody create secret generic laravel-secret \
  --from-literal=APP_KEY='base64:...'
```

***

### 16) Deploy MySQL (simple, single-node storage pakai hostPath di worker)

#### 16.1 Tentukan node worker name

```bash
kubectl get nodes
```

Misal worker node name = `worker`.

#### 16.2 Buat PV/PVC + Deployment MySQL

Buat `k8s/mysql.yaml`:

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: mysql-pv
spec:
  capacity:
    storage: 5Gi
  accessModes: ["ReadWriteOnce"]
  persistentVolumeReclaimPolicy: Retain
  storageClassName: ""
  local:
    path: /var/lib/threebody-mysql
  nodeAffinity:
    required:
      nodeSelectorTerms:
        - matchExpressions:
            - key: kubernetes.io/hostname
              operator: In
              values: ["worker"]   # ganti sesuai node worker kamu
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
  namespace: threebody
spec:
  accessModes: ["ReadWriteOnce"]
  storageClassName: ""
  resources:
    requests:
      storage: 5Gi
  volumeName: mysql-pv
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
  namespace: threebody
spec:
  replicas: 1
  selector:
    matchLabels: {app: mysql}
  template:
    metadata:
      labels: {app: mysql}
    spec:
      nodeSelector:
        kubernetes.io/hostname: "worker"   # ganti sesuai node worker
      containers:
        - name: mysql
          image: mysql:8.0
          envFrom:
            - secretRef:
                name: db-secret
          env:
            - name: MYSQL_ROOT_HOST
              value: "%"
          ports:
            - containerPort: 3306
          volumeMounts:
            - name: data
              mountPath: /var/lib/mysql
      volumes:
        - name: data
          persistentVolumeClaim:
            claimName: mysql-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: mysql
  namespace: threebody
spec:
  selector: {app: mysql}
  ports:
    - port: 3306
      targetPort: 3306
```

Apply:

```bash
# bikin folder di worker node (sekali saja)
ssh cikal@worker.local 'sudo mkdir -p /var/lib/threebody-mysql && sudo chown -R 999:999 /var/lib/threebody-mysql'

kubectl apply -f k8s/mysql.yaml
kubectl -n threebody get pods -w
```

***

### 17) Deploy Laravel + Go + Frontend (image dari Harbor)

Buat `k8s/apps.yaml` (TAG nanti dari CI):

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: laravel
  namespace: threebody
spec:
  replicas: 1
  selector:
    matchLabels: {app: laravel}
  template:
    metadata:
      labels: {app: laravel}
    spec:
      containers:
        - name: laravel
          image: harbor.local/threebody/laravel:TAG
          ports:
            - containerPort: 8001
          env:
            - name: APP_ENV
              value: "production"
            - name: DB_HOST
              value: "mysql"
            - name: DB_DATABASE
              valueFrom: {secretKeyRef: {name: db-secret, key: MYSQL_DATABASE}}
            - name: DB_USERNAME
              valueFrom: {secretKeyRef: {name: db-secret, key: MYSQL_USER}}
            - name: DB_PASSWORD
              valueFrom: {secretKeyRef: {name: db-secret, key: MYSQL_PASSWORD}}
            - name: APP_KEY
              valueFrom: {secretKeyRef: {name: laravel-secret, key: APP_KEY}}
---
apiVersion: v1
kind: Service
metadata:
  name: laravel
  namespace: threebody
spec:
  selector: {app: laravel}
  ports:
    - port: 8001
      targetPort: 8001
  type: NodePort
  nodePort: 30081
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: go
  namespace: threebody
spec:
  replicas: 1
  selector:
    matchLabels: {app: go}
  template:
    metadata:
      labels: {app: go}
    spec:
      containers:
        - name: go
          image: harbor.local/threebody/go:TAG
          ports:
            - containerPort: 8080
          env:
            - name: DB_HOST
              value: "mysql"
            - name: DB_NAME
              valueFrom: {secretKeyRef: {name: db-secret, key: MYSQL_DATABASE}}
            - name: DB_USER
              valueFrom: {secretKeyRef: {name: db-secret, key: MYSQL_USER}}
            - name: DB_PASS
              valueFrom: {secretKeyRef: {name: db-secret, key: MYSQL_PASSWORD}}
---
apiVersion: v1
kind: Service
metadata:
  name: go
  namespace: threebody
spec:
  selector: {app: go}
  ports:
    - port: 8080
      targetPort: 8080
  type: NodePort
  nodePort: 30082
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: threebody
spec:
  replicas: 1
  selector:
    matchLabels: {app: frontend}
  template:
    metadata:
      labels: {app: frontend}
    spec:
      containers:
        - name: frontend
          image: harbor.local/threebody/frontend:TAG
          ports:
            - containerPort: 3000
---
apiVersion: v1
kind: Service
metadata:
  name: frontend
  namespace: threebody
spec:
  selector: {app: frontend}
  ports:
    - port: 3000
      targetPort: 3000
  type: NodePort
  nodePort: 30030
```

> Catatan: kalau image frontend kamu static Nginx (port 80), sesuaikan service ke 80.

Apply (manual test):

```bash
sed "s/:TAG/:dev/g" k8s/apps.yaml | kubectl apply -f -
kubectl -n threebody get pods -o wide
```

***

## BAGIAN F — HTTPS + RATE LIMITING (tanpa ingress)

Karena kamu minta **tanpa ingress**, cara paling gampang & jelas adalah:

✅ **Nginx di host VM k8s (systemd)** sebagai “edge proxy” HTTPS + rate limit\
➡️ Nginx forward ke NodePort: `30030/30081/30082`

### 18) Nginx Edge di VM kubernetes (192.168.56.44)

#### 18.1 Install Nginx

```bash
sudo apt-get update
sudo apt-get -y install nginx openssl
```

#### 18.2 Buat cert untuk `prod.local`

```bash
sudo mkdir -p /etc/nginx/certs
cd /etc/nginx/certs
sudo openssl genrsa -out prod.local.key 2048
sudo openssl req -x509 -new -nodes -days 3650 \
  -subj "/C=ID/ST=Jakarta/L=Jakarta/O=Lab/OU=DevOps/CN=prod.local" \
  -key prod.local.key -out prod.local.crt
```

#### 18.3 Konfigurasi Nginx (HTTPS + rate limit)

```bash
sudo tee /etc/nginx/sites-available/threebody >/dev/null <<'EOF'
limit_req_zone $binary_remote_addr zone=api_rate:10m rate=10r/s;

server {
  listen 80;
  server_name prod.local;
  return 301 https://$host$request_uri;
}

server {
  listen 443 ssl;
  server_name prod.local;

  ssl_certificate     /etc/nginx/certs/prod.local.crt;
  ssl_certificate_key /etc/nginx/certs/prod.local.key;

  location / {
    proxy_pass http://127.0.0.1:30030;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-Proto https;
    proxy_set_header X-Forwarded-For $remote_addr;
  }

  location /api/laravel/ {
    limit_req zone=api_rate burst=20 nodelay;
    proxy_pass http://127.0.0.1:30081/;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-Proto https;
    proxy_set_header X-Forwarded-For $remote_addr;
  }

  location /api/go/ {
    limit_req zone=api_rate burst=20 nodelay;
    proxy_pass http://127.0.0.1:30082/;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-Proto https;
    proxy_set_header X-Forwarded-For $remote_addr;
  }

  location /healthz { return 200 "ok\n"; }
}
EOF

sudo ln -sf /etc/nginx/sites-available/threebody /etc/nginx/sites-enabled/threebody
sudo nginx -t
sudo systemctl restart nginx
```

Tes:

```bash
curl -k https://prod.local/healthz
```

***

## BAGIAN G — LOGGING TERINTEGRASI (Loki + Grafana)

> Grafana sekarang menyarankan pakai **chart Loki** (bukan loki-stack, karena loki-stack deprecated). ([GitHub](https://github.com/grafana/helm-charts/blob/main/charts/loki-stack/README.md?utm_source=chatgpt.com))

### 19) Install Helm (di VM k8s)

```bash
curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
helm version
```

### 20) Install Loki + Promtail + Grafana (simple untuk lab)

```bash
helm repo add grafana https://grafana.github.io/helm-charts
helm repo update
kubectl create namespace observability
```

#### 20.1 Install Loki (mode monolithic cocok untuk cluster kecil) ([Grafana Labs](https://grafana.com/docs/loki/latest/setup/install/helm/))

```bash
helm -n observability install loki grafana/loki \
  --set loki.auth_enabled=false
```

#### 20.2 Install Promtail (agent log collector)

```bash
helm -n observability install promtail grafana/promtail \
  --set "config.clients[0].url=http://loki:3100/loki/api/v1/push"
```

#### 20.3 Install Grafana

```bash
helm -n observability install grafana grafana/grafana \
  --set service.type=NodePort \
  --set service.nodePort=30080
```

Ambil password:

```bash
kubectl -n observability get secret grafana -o jsonpath="{.data.admin-password}" | base64 -d; echo
```

Akses dari host/laptop:

* `http://prod.local:30080` (atau `http://192.168.56.44:30080`)
* user: `admin`
* pass: hasil command di atas

Tambahkan datasource Loki:

* URL: `http://loki:3100`

Cek log:

* Grafana → Explore → pilih Loki → query `{namespace="threebody"}`

***

## BAGIAN H — GITLAB CI/CD + SECRETS (GitLab Variables)

### 21) Variables wajib di GitLab (Settings → CI/CD → Variables)

Set **masked** + **protected** kalau untuk branch tertentu.

**Harbor:**

* `HARBOR_URL=harbor.local`
* `HARBOR_PROJECT=threebody`
* `HARBOR_USERNAME=admin` (atau robot)
* `HARBOR_PASSWORD=...`

**DB:**

* `MYSQL_ROOT_PASSWORD=...`
* `MYSQL_DATABASE=threebody`
* `MYSQL_USER=threebody`
* `MYSQL_PASSWORD=...`

**Laravel:**

* `LARAVEL_APP_KEY=base64:...`

**Kubernetes deploy:**

* `KUBECONFIG_B64=...` (base64 dari kubeconfig)

#### 21.1 Buat `KUBECONFIG_B64`

Di VM k8s:

```bash
cat ~/.kube/config > /tmp/kubeconfig
# pastikan server mengarah ke IP host-only:
# server: https://192.168.56.44:6443
sed -i 's#server: https://.*:6443#server: https://192.168.56.44:6443#g' /tmp/kubeconfig

base64 -w0 /tmp/kubeconfig
```

Copy output ke GitLab Variable `KUBECONFIG_B64`.

***

### 22) Install GitLab Runner di VM docker (shell executor)

```bash
curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash
sudo apt-get -y install gitlab-runner
sudo gitlab-runner register
```

Isi saat register:

* URL: GitLab kamu
* Token: dari project runners
* Executor: `shell`
* Tags: `deploy`

Pastikan runner bisa docker:

```bash
sudo usermod -aG docker gitlab-runner
sudo systemctl restart gitlab-runner
```

***

### 23) `.gitlab-ci.yml` (full: build+push+deploy staging+deploy prod+healthcheck)

> Ini template “langsung jalan” di runner shell VM docker.

```yaml
stages: [test, build_push, deploy_staging, verify_staging, deploy_prod, verify_prod]

variables:
  DOCKER_BUILDKIT: "1"
  REG: "$HARBOR_URL/$HARBOR_PROJECT"
  TAG: "$CI_COMMIT_SHA"

default:
  tags: ["deploy"]
  before_script:
    - set -euo pipefail

test:
  stage: test
  script:
    - echo "Run lightweight tests (optional)"
    - test -f go/go.mod && (cd go && go test ./... || true)
    - test -f laravel/artisan && (cd laravel && php -v || true)

build_push:
  stage: build_push
  script:
    - : "${HARBOR_URL:?}" "${HARBOR_PROJECT:?}" "${HARBOR_USERNAME:?}" "${HARBOR_PASSWORD:?}"
    - docker login "$HARBOR_URL" -u "$HARBOR_USERNAME" -p "$HARBOR_PASSWORD"
    - docker build -f laravel/Dockerfile  -t "$REG/laravel:$TAG"  .
    - docker build -f go/Dockerfile       -t "$REG/go:$TAG"       .
    - docker build -f frontend/Dockerfile -t "$REG/frontend:$TAG" .
    - docker push "$REG/laravel:$TAG"
    - docker push "$REG/go:$TAG"
    - docker push "$REG/frontend:$TAG"

deploy_staging:
  stage: deploy_staging
  script:
    - export TAG="$TAG"
    - docker compose -f docker-compose.staging.yml up -d
    - docker compose -f docker-compose.staging.yml ps

verify_staging:
  stage: verify_staging
  script:
    - curl -kfsS https://staging.local/healthz
    - echo "Staging OK"

deploy_prod:
  stage: deploy_prod
  script:
    - echo "$KUBECONFIG_B64" | base64 -d > /tmp/kubeconfig
    - export KUBECONFIG=/tmp/kubeconfig
    - kubectl cluster-info
    - kubectl get ns threebody >/dev/null 2>&1 || kubectl create ns threebody
    # secrets (idempotent)
    - |
      kubectl -n threebody create secret generic db-secret \
        --from-literal=MYSQL_ROOT_PASSWORD="$MYSQL_ROOT_PASSWORD" \
        --from-literal=MYSQL_DATABASE="$MYSQL_DATABASE" \
        --from-literal=MYSQL_USER="$MYSQL_USER" \
        --from-literal=MYSQL_PASSWORD="$MYSQL_PASSWORD" \
        --dry-run=client -o yaml | kubectl apply -f -
    - |
      kubectl -n threebody create secret generic laravel-secret \
        --from-literal=APP_KEY="$LARAVEL_APP_KEY" \
        --dry-run=client -o yaml | kubectl apply -f -
    # apply mysql + apps with tag
    - kubectl apply -f k8s/mysql.yaml
    - sed "s/:TAG/:$TAG/g" k8s/apps.yaml | kubectl apply -f -
    - kubectl -n threebody rollout status deploy/mysql --timeout=180s || true
    - kubectl -n threebody rollout status deploy/laravel --timeout=180s
    - kubectl -n threebody rollout status deploy/go --timeout=180s
    - kubectl -n threebody rollout status deploy/frontend --timeout=180s

verify_prod:
  stage: verify_prod
  script:
    - curl -kfsS https://prod.local/healthz
    - echo "Production OK"
```

***

## BAGIAN I — Dokumen Sistem Design DRC (copy ke README)

### Tujuan DRC

Menjamin layanan bisa pulih bila site utama down.\
Contoh target:

* **RPO:** 15 menit
* **RTO:** 1 jam

### Komponen yang wajib diproteksi

* **MySQL** (data utama)
* **Harbor** (image registry)
* **GitLab repo + CI config**
* **Kubernetes manifests** (`k8s/*.yaml`, values Helm)
* **Observability** (Loki/Grafana) — opsional tapi bagus untuk audit

### Strategi Backup & Replikasi

#### MySQL

* Daily full backup + (opsional) binlog/incremental
* Simpan ke storage terpisah (NFS/S3/MinIO di site DRC)
* Uji restore berkala

#### Harbor

* Gunakan **Harbor Replication Rule** (primary → DRC registry)
* Atur schedule (misal tiap 30 menit) untuk project `threebody`

#### Kubernetes

* Git sebagai **source of truth**
* Untuk stateful (MySQL): restore dari dump DB, lalu redeploy manifests

### Failover Plan (ringkas)

1. Deklarasikan incident, freeze deploy.
2. Restore MySQL dari backup terbaru di cluster DRC.
3. Pastikan Harbor DRC punya image tags terbaru (replication).
4. Apply manifests/helm ke cluster DRC.
5. Switch DNS / hosts ke endpoint DRC.
6. Validasi healthcheck + logs + smoke test endpoint.

***

## BAGIAN J — Checklist Submission (Screenshot)

* Harbor UI: project `threebody` + list images (tag commit SHA)
* GitLab pipeline sukses (semua stage hijau)
* `docker compose ps` di VM docker (staging)
* `kubectl get pods -A` (prod)
* Browser:
  * `https://staging.local` (atau `https://prod.local`)
* Grafana Explore: log dari namespace `threebody`

***

### Troubleshooting cepat (yang paling sering kejadian)

* **Node NotReady setelah init:** biasanya CNI belum terpasang / pod network belum ready.
* **ImagePullBackOff dari Harbor:** CA belum dipasang benar di containerd node (cek `/etc/containerd/certs.d/harbor.local/*`), lalu restart containerd.
* **Nginx prod tidak bisa proxy NodePort:** pastikan service NodePort benar & listening (`curl http://127.0.0.1:30030` dari VM k8s).

***

Kalau kamu mau langkah berikutnya, aku bisa **rapihin struktur repo** biar enak dipipeline:

* `k8s/` (yaml siap CI, pakai placeholder TAG)
* `ops/nginx/` (staging & prod)
* `scripts/healthcheck.sh`
* README final (arsitektur + runbook singkat + DRC)
