# 0. DevOps V3.1.2 update

Sip — aku **nggak mengira-ngira** ya. Dari log yang kamu kirim, ini yang benar-benar terjadi dan apa yang harus dibenarkan di runbook.

### 1) Hasil cek (berdasarkan data kamu)

#### A) Kenapa `containerd` di **vm-k8s** gagal start?

Di journal jelas:

* `failed to load TOML ... parsing error: keys cannot contain \ character`
* Kamu cek file-nya dan ketemu baris ini:

```
162  \1  config_path = "/etc/containerd/certs.d"
```

Jadi penyebabnya **bukan containerd/package rusak**, tapi **config.toml jadi invalid** karena perintah `sed` di runbook memasukkan literal `\1` ke file TOML (itu memang bikin containerd restart-loop).

✅ Solusi yang kamu jalankan terakhir **sudah benar dan aman**:

* regenerate config default
* set `SystemdCgroup = true`
* set `registry.config_path = "/etc/containerd/certs.d"` dengan metode “range replace”
* containerd akhirnya `active`

Itu fix yang tepat.

***

#### B) Kenapa kamu kemarin tidak menemukan `edge.conf`?

Kamu menjalankan:

```bash
cd deploy/edge/certs
grep -n "proxy_pass" -n deploy/edge/nginx/conf.d/edge.conf
```

Karena kamu sedang berada di folder `deploy/edge/certs`, path itu jadi nyari:\
`deploy/edge/certs/deploy/edge/nginx/...` (dobel)

✅ File edge.conf **ada** di project yang kamu unzip, lokasinya:

* `~/three-body-problem/deploy/edge/nginx/conf.d/edge.conf`

Jadi “aneh”-nya cuma **path relatifnya**.

***

### 2) RUNBOOK FINAL (FULL REPLACE) — 3 VM kosong, sekali push, anti kendala lama

Di bawah ini aku susun ulang runbook yang **menghindari semua masalah yang sudah kamu alami**:

* apt/dpkg lock & service restart random
* DNS GitLab / resolv.conf
* runner tidak bisa docker
* kubeadm init/join / 6443 refused
* worker NotReady
* containerd registry config\_path & insecure Harbor HTTP
* imagePullBackOff karena secret / registry
* edge nginx proxy & path yang salah
* akses NodePort gagal karena IP salah / firewall

> **Asumsi OS:** Ubuntu 24.04 (noble) di semua VM\
> **Skema IP (kamu boleh ganti, tapi harus konsisten):**
>
> * **vm-docker** = `192.168.56.42` (Harbor HTTP `:8080` + Edge `hit.local` + GitLab Runner)
> * **vm-k8s** = `192.168.56.43` (control-plane)
> * **vm-worker** = `192.168.56.44` (worker, NodePort `30080/30081/30082`)
>
> Kalau kamu pakai IP berbeda, **ganti di 3 tempat ini saja**:
>
> 1. `/etc/hosts` semua VM
> 2. `deploy/edge/nginx/conf.d/edge.conf` (IP worker)
> 3. `kubeadm init --apiserver-advertise-address=...`

***

## A. LANGKAH WAJIB DI SEMUA VM (vm-docker, vm-k8s, vm-worker)

#### A1) HARDEN semua VM: matikan auto update & cegah restart service otomatis

> Jalankan di **SEMUA VM**: `vm-docker`, `vm-harbor`, `vm-k8s`, `vm-worker`

```bash
sudo systemctl stop unattended-upgrades 2>/dev/null || true
sudo systemctl disable --now unattended-upgrades 2>/dev/null || true

sudo systemctl stop apt-daily.service apt-daily-upgrade.service 2>/dev/null || true
sudo systemctl disable --now apt-daily.timer apt-daily-upgrade.timer 2>/dev/null || true

# rapikan dpkg kalau pernah kepotong
sudo dpkg --configure -a || true
```

Kalau file needrestart ada, set supaya **tidak auto-restart service**:

```bash
if [ -f /etc/needrestart/needrestart.conf ]; then
  sudo cp -a /etc/needrestart/needrestart.conf /etc/needrestart/needrestart.conf.bak.$(date +%F-%H%M%S)
  sudo sed -i "s/^\s*\$nrconf{restart}.*/\$nrconf{restart} = 'l';/" /etc/needrestart/needrestart.conf || true
fi
```

> Mode `'l'` = cuma list, **tidak restart service** otomatis.

***

#### ✅ ADD-ON (tempel di sini): PRE-FLIGHT GLOBAL + APT LOCK UNIVERSAL <a href="#add-on-tempel-di-sini-pre-flight-global--apt-lock-universal" id="add-on-tempel-di-sini-pre-flight-global--apt-lock-universal"></a>

> Jalankan ini **sekali** setelah HARDEN di **setiap VM**, terutama VM kosong yang baru selesai install OS.

```bash
# =========================================================
# ADD-ON: PRE-FLIGHT GLOBAL (jalankan di SEMUA VM)
# =========================================================
echo "=== BASIC ==="
hostname
ip -br a | sed -n '1,10p'
ip r

echo "=== DNS / HOSTS (harus resolve) ==="
getent hosts harbor.local prod.local staging.local vm-k8s vm-worker vm-docker || true

echo "=== APT/Dpkg Lock ==="
sudo fuser /var/lib/dpkg/lock-frontend 2>/dev/null && echo "dpkg lock DIPAKAI" || echo "dpkg lock aman"

echo "=== STORAGE/RAM (biar kube-apiserver gak 'refused') ==="
df -h | sed -n '1,10p'
free -h
```

> Kalau apt/dpkg macet kapanpun, pakai ini (universal):

```bash
# =========================================================
# ADD-ON: APT LOCK UNIVERSAL FIX (pakai kalau apt/dpkg macet)
# =========================================================
sudo systemctl stop unattended-upgrades apt-daily.service apt-daily-upgrade.service 2>/dev/null || true
pgrep -a unattended-upgrade || true
pgrep -a apt.systemd.daily || true

sudo rm -f /var/lib/dpkg/lock-frontend /var/lib/dpkg/lock /var/cache/apt/archives/lock
sudo dpkg --configure -a || true
sudo apt-get -f install -y || true
sudo apt-get update -y
```

### A2) Set hostname

Jalankan sesuai VM:

**vm-docker**

```bash
sudo hostnamectl set-hostname vm-docker
```

**vm-k8s**

```bash
sudo hostnamectl set-hostname vm-k8s
```

**vm-worker**

```bash
sudo hostnamectl set-hostname vm-worker
```

### A3) `/etc/hosts` wajib (biar `harbor.local` & `hit.local` stabil)

Jalankan di **SEMUA VM**:

```bash
sudo tee /etc/hosts >/dev/null <<'EOF'
127.0.0.1 localhost
192.168.56.42 vm-docker harbor.local hit.local
192.168.56.43 vm-k8s
192.168.56.44 vm-worker
EOF

getent hosts harbor.local hit.local vm-k8s vm-worker
hostname
```

### A4) DNS fix (menghindari “GitLab kadang resolve kadang tidak”)

Jalankan di **SEMUA VM**:

```bash
sudo tee /etc/systemd/resolved.conf >/dev/null <<'EOF'
[Resolve]
DNS=1.1.1.1 8.8.8.8
FallbackDNS=9.9.9.9 8.8.4.4
DNSStubListener=yes
EOF

sudo systemctl restart systemd-resolved
sudo resolvectl flush-caches

# penting: resolv.conf pakai nameserver real, bukan 127.0.0.53
sudo ln -sf /run/systemd/resolve/resolv.conf /etc/resolv.conf

getent hosts gitlab.com altssh.gitlab.com registry-1.docker.io || true
```

***

## B. VM-DOCKER (192.168.56.42) — Docker + Harbor + Edge + GitLab Runner

### B1) Install tools + Docker

```bash
sudo apt-get update -y
sudo apt-get install -y ca-certificates curl git nano unzip rsync openssl openssh-server
sudo apt install ufw
sudo apt install lsof
sudo systemctl enable --now ssh
sudo ufw enable
echo "=== [Firewall] pastikan port 8080 tidak diblok ==="
sudo ufw status verbose || true
# kalau UFW aktif, BUKA port 8080:
sudo ufw allow 8080/tcp || true
sudo ufw allow ssh
sudo ufw reload || true

curl -fsSL https://get.docker.com | sudo sh
sudo usermod -aG docker "$USER"
newgrp docker

docker version
docker compose version
```

### B2) Docker allow insecure registry Harbor (HTTP)

```bash
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json >/dev/null <<'EOF'
{
  "insecure-registries": ["harbor.local:8080"]
}
EOF

sudo systemctl restart docker
docker info | egrep -i "insecure|registry" || true
```

### ✅ ADD-ON 2 (tempel setelah `B2) Docker allow insecure registry Harbor (HTTP)` ATAU setelah ADD-ON 1 di atas)

> Tujuan: memastikan **docker daemon** sudah benar-benar mengizinkan insecure registry, dan runner (user `gitlab-runner`) bisa resolve & akses Harbor.

```bash
# =========================================================
# ADD-ON: VALIDASI DOCKER + RUNNER BISA AKSES HARBOR
# Tempel setelah B2 (atau setelah ADD-ON Harbor UP)
# =========================================================

echo "=== [Docker] pastikan insecure registry kebaca ==="
docker info | egrep -i "insecure|registry" || true

echo "=== [DNS] pastikan harbor.local resolve ke IP yang benar ==="
getent hosts harbor.local

echo "=== [Runner] cek dari konteks user gitlab-runner ==="
sudo -u gitlab-runner getent hosts harbor.local || true
sudo -u gitlab-runner bash -lc 'curl -fsSI http://harbor.local:8080/v2/ | head -n 1' || true
```

### B3) Install Harbor (HTTP :8080)

> Harbor jalan di container `nginx` milik Harbor, port **8080**.

```bash
export HARBOR_VERSION="v2.14.1"

cd /tmp
wget -O "harbor-offline-installer-${HARBOR_VERSION}.tgz" \
  "https://github.com/goharbor/harbor/releases/download/${HARBOR_VERSION}/harbor-offline-installer-${HARBOR_VERSION}.tgz"

tar -xzf "harbor-offline-installer-${HARBOR_VERSION}.tgz"

sudo rm -rf /opt/harbor
sudo mv harbor /opt/harbor
sudo chown -R "$USER:$USER" /opt/harbor
```

Edit `harbor.yml`:

```bash
cd /opt/harbor
cp harbor.yml.tmpl harbor.yml
nano harbor.yml
```

Isi minimal:

```yaml
hostname: harbor.local
http:
  port: 8080

# pastikan TIDAK ada https aktif
harbor_admin_password: Harbor12345
data_volume: /data/harbor
trivy:
  enabled: false
```

Install & cek:

```bash
sudo mkdir -p /data/harbor
sudo ./prepare
sudo ./install.sh

sudo docker compose -f /opt/harbor/docker-compose.yml ps
curl -fsSI http://harbor.local:8080/v2/ | head -n 1 || true
```

Di UI Harbor:

* `http://harbor.local:8080/`
* Buat project: **threebody**

### ✅ ADD-ON 1 (tempel tepat setelah bagian `B3) Install Harbor (HTTP :8080)`)

> Tujuan: memastikan Harbor **benar-benar UP** dan **listen di 8080** sebelum kamu lanjut ke step berikutnya / sebelum push pertama ke GitLab.

```bash
# =========================================================
# ADD-ON: HARBOUR MUST BE UP (wajib sebelum pipeline pertama)
# Tempel setelah B3 (Install & cek Harbor)
# =========================================================

echo "=== [Harbor] cek container status ==="
sudo docker compose -f /opt/harbor/docker-compose.yml ps

echo "=== [Harbor] pastikan port 8080 LISTEN di host ==="
# harus ada output LISTEN untuk :8080
sudo ss -lntp | grep ':8080' || true

echo "=== [Harbor] sanity check endpoint /v2 (401 normal) ==="
# target: dapat HTTP/1.1 401 Unauthorized (yang penting bukan connection refused)
curl -fsSI http://harbor.local:8080/v2/ | head -n 1 || true

echo "=== [Harbor] kalau masih connection refused: start ulang Harbor ==="
cd /opt/harbor
sudo docker compose -f /opt/harbor/docker-compose.yml up -d
sudo docker compose -f /opt/harbor/docker-compose.yml ps

echo "=== [Harbor] cek log nginx harbor kalau masih gagal ==="
# cari error bind port / crash loop
sudo docker compose -f /opt/harbor/docker-compose.yml logs --tail=120 nginx || true
sudo docker compose -f /opt/harbor/docker-compose.yml logs --tail=120 harbor-core || true
sudo docker compose -f /opt/harbor/docker-compose.yml logs --tail=120 registry || true

echo "=== [Harbor] cek lagi port 8080 & /v2 ==="
sudo ss -lntp | grep ':8080' || true
curl -fsSI http://harbor.local:8080/v2/ | head -n 1 || true

echo "=== [Harbor] cek konflik port (kalau 8080 tidak bisa bind) ==="
# kalau ada service lain pakai 8080, akan kelihatan di sini
sudo lsof -iTCP:8080 -sTCP:LISTEN -nP || true
```

## ✅ ADD-ON B (Opsional tapi sangat membantu): “Harbor readiness gate sebelum push pertama”

Kenapa perlu? Karena error pertama kamu dulu adalah **Harbor belum reachable**, sehingga job `push_images` gagal.

**Tempel di runbook bagian B3 (Install Harbor), tepat setelah langkah “Install & cek Harbor”.**

```bash
# =========================================================
# ADD-ON: HARBOR READINESS GATE (wajib sebelum pipeline pertama)
# Jalankan di vm-docker
# =========================================================
echo "=== Harbor containers ==="
sudo docker compose -f /opt/harbor/docker-compose.yml ps

echo "=== Port 8080 must LISTEN ==="
sudo ss -lntp | grep ':8080'

echo "=== /v2 must respond (401 is OK) ==="
curl -fsSI http://harbor.local:8080/v2/ | head -n 1
```

Patokan:

* ada LISTEN `:8080`
* `/v2` balas `HTTP/1.1 401 Unauthorized`

Kalau ini lolos, job push akan aman.

### B4) Deploy project “three-body-problem” + Edge Nginx (hit.local)

#### ✅ ADD-ON LARAVEL READY (wajib)

**Tempatkan:** di runbook **B4 (setelah unzip repo & sebelum E2 Push pertama)**

```bash
# =========================================================
# ADD-ON: FIX LARAVEL APACHE DOCROOT (WAJIB sebelum push pertama)
# Lokasi: vm-docker, setelah repo siap, sebelum git push pertama
# =========================================================
cd ~/three-body-problem

echo "=== cek Dockerfile Laravel sudah set APACHE_DOCUMENT_ROOT ke /public ==="
grep -n "APACHE_DOCUMENT_ROOT" -n laravel/Dockerfile || true
grep -n "laravel.conf" -n laravel/Dockerfile || true

echo "Jika belum ada APACHE_DOCUMENT_ROOT=/var/www/html/public, lakukan FULL REPLACE laravel/Dockerfile sesuai runbook."
```

Pastikan kamu di root repo saat cek file (biar nggak kejadian salah path lagi):

```bash
cd ~
unzip -q three-body-problem-final.zip
mv three-body-problem-final three-body-problem
cd ~/three-body-problem

# cek edge.conf beneran ada
ls -lah deploy/edge/nginx/conf.d/edge.conf
grep -n "proxy_pass" deploy/edge/nginx/conf.d/edge.conf
```

Buat cert:

```bash
cd ~/three-body-problem
mkdir -p deploy/edge/certs
cd deploy/edge/certs

openssl req -x509 -nodes -newkey rsa:2048 -days 3650 \
  -keyout tls.key -out tls.crt \
  -subj "/CN=hit.local"
```

Naikkan edge:

```bash
cd ~/three-body-problem/deploy/edge
sudo docker compose up -d

# test config nginx di dalam container (bukan nginx di host)
sudo docker exec -it edge-nginx nginx -t
```

Tes akses:

```bash
curl -vk --resolve hit.local:443:127.0.0.1 https://hit.local/ 2>&1 | tail -n 20
```

### B5) Install GitLab Runner + pastikan runner bisa docker

```bash
curl -L "https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh" | sudo bash
sudo apt-get install -y gitlab-runner
sudo systemctl enable --now gitlab-runner

sudo usermod -aG docker gitlab-runner
sudo chown root:docker /var/run/docker.sock
sudo chmod 660 /var/run/docker.sock

sudo systemctl restart docker
sudo systemctl restart gitlab-runner

sudo -u gitlab-runner docker ps
```

Register runner (sekali, interaktif):

```bash
sudo gitlab-runner register
```

* executor: `shell`
* tags: `deploy`
* untagged: `false`

### B6) SSH GitLab via port 443 (kalau port 22 bermasalah)

```bash
ssh-keygen -t ed25519 -C "vm-docker-gitlab" -f ~/.ssh/id_ed25519 -N ""

cat <<'EOF' > ~/.ssh/config
Host gitlab-443
  HostName altssh.gitlab.com
  User git
  Port 443
  IdentityFile ~/.ssh/id_ed25519
  IdentitiesOnly yes
  StrictHostKeyChecking accept-new
EOF

chmod 600 ~/.ssh/config ~/.ssh/id_ed25519
```

Copas semua hasil command dibawah untuk di input ke gitlab

```bash
cat ~/.ssh/id_ed25519.pub
```

Tes koneksi

```bash
ssh -T git@gitlab-443
```

***

## C. VM-K8S (192.168.56.43) — Kubernetes control-plane

### C1) Prasyarat kernel + swap off

```bash
sudo apt-get update -y
sudo apt-get install -y ca-certificates curl nano apt-transport-https gpg openssh-server
sudo systemctl enable --now ssh

sudo swapoff -a
sudo sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab

cat <<'EOF' | sudo tee /etc/modules-load.d/k8s.conf >/dev/null
overlay
br_netfilter
EOF
sudo modprobe overlay
sudo modprobe br_netfilter

cat <<'EOF' | sudo tee /etc/sysctl.d/99-kubernetes.conf >/dev/null
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF
sudo sysctl --system
```

Kalau ada swapfile bawaan (seperti kasus kamu `/swap.img`):

```bash
sudo rm -f /swap.img
```

Verifikasi:

```bash
swapon --show
```

Harus kosong.

### C2) Install + konfigurasi containerd (VERSI AMAN, TANPA `\1`)

> Ini versi yang **kamu buktikan bekerja** (full replace dari runbook lama).

```bash
sudo apt-get install -y containerd

sudo systemctl stop containerd || true
sudo mkdir -p /etc/containerd
containerd config default | sudo tee /etc/containerd/config.toml >/dev/null

# WAJIB: systemd cgroup
sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/g' /etc/containerd/config.toml

# WAJIB: registry config_path -> /etc/containerd/certs.d
sudo sed -i \
'/\[plugins\."io\.containerd\.grpc\.v1\.cri"\.registry\]/,/^\[/{s/^[[:space:]]*config_path[[:space:]]*=.*/      config_path = "\/etc\/containerd\/certs.d"/}' \
/etc/containerd/config.toml

sudo systemctl enable --now containerd
sudo systemctl restart containerd
sudo systemctl is-active containerd
```

Cek aman:

```bash
sudo grep -n '\\1' /etc/containerd/config.toml || echo "OK: tidak ada \\1"
sudo grep -nE '\[plugins\."io\.containerd\.grpc\.v1\.cri"\.registry\]|config_path' /etc/containerd/config.toml | head -n 40
```

### C3) Allow Harbor HTTP untuk containerd (pull dari harbor.local:8080)

```bash
sudo mkdir -p /etc/containerd/certs.d/harbor.local:8080

sudo tee /etc/containerd/certs.d/harbor.local:8080/hosts.toml >/dev/null <<'EOF'
server = "http://harbor.local:8080"

[host."http://harbor.local:8080"]
  capabilities = ["pull", "resolve", "push"]
EOF

sudo systemctl restart containerd
sudo systemctl is-active containerd
```

### C4) Install kubeadm/kubelet/kubectl v1.30

```bash
sudo mkdir -p -m 0755 /etc/apt/keyrings
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key \
  | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg

echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] \
https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /" \
  | sudo tee /etc/apt/sources.list.d/kubernetes.list

sudo apt-get update -y
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl
```

### C5) `kubeadm init` + Calico

```bash
sudo kubeadm init \
  --apiserver-advertise-address=192.168.56.43 \
  --apiserver-cert-extra-sans=192.168.56.43,vm-k8s \
  --pod-network-cidr=192.168.0.0/16

mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown "$(id -u)":"$(id -g)" $HOME/.kube/config

kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.28.0/manifests/calico.yaml
kubectl get nodes -o wide
```

```bash
watch -n 2 -d 'kubectl get nodes'
```

Ambil join command:

```bash
kubeadm token create --print-join-command --ttl 24h
```

***

## D. VM-WORKER (192.168.56.44) — Kubernetes worker + NodePort

### D1) Ulangi langkah containerd yang SAMA seperti vm-k8s

Jalankan di vm-worker: **C1 + C2 + C3 + C4** (swap off, sysctl, containerd safe config, hosts.toml Harbor, install kubeadm/kubelet/kubectl).

Kalau ada swapfile bawaan (seperti kasus kamu `/swap.img`):

```bash
sudo rm -f /swap.img
```

Verifikasi:

```bash
swapon --show
```

Harus kosong.

### D2) Join cluster

Pakai command dari vm-k8s, contoh:

```bash
sudo kubeadm join 192.168.56.43:6443 --token <TOKEN> --discovery-token-ca-cert-hash sha256:<HASH>
```

Cek dari vm-k8s:

```bash
kubectl get nodes -o wide
```

### D3) Siapkan hostPath MySQL (sesuai manifest kamu)

Karena PV kamu pakai:

* `/data/threebody/mysql`\
  dan nodeAffinity ke hostname `vm-worker`

Maka di vm-worker:

```bash
sudo mkdir -p /data/threebody/mysql
sudo chown -R 999:999 /data/threebody/mysql || true
sudo chmod 700 /data/threebody/mysql || true
```

### D4) Firewall (biar NodePort bisa diakses dari vm-docker)

Untuk lab paling simpel: **matikan ufw** di vm-worker & vm-k8s:

```bash
sudo ufw disable || true
```

Kalau kamu mau tetap pakai ufw, minimal di vm-worker:

```bash
sudo ufw allow 30080:30082/tcp
sudo ufw reload
sudo ufw status verbose
```

***

## E. GITLAB CI/CD — “sekali push langsung deploy”

### E1) GitLab Variables (Project → Settings → CI/CD → Variables)

Wajib:

* `HARBOR_USERNAME` = `admin`
* `HARBOR_PASSWORD` = `Harbor12345`
* `MYSQL_ROOT_PASSWORD` = (bebas)
* `MYSQL_DATABASE` = `threebody`
* `MYSQL_USER` = `admin`
* `MYSQL_PASSWORD` = (bebas)
* `LARAVEL_APP_KEY` = `base64:...`
* `KUBECONFIG_PROD` **Type: File** (isi dari `~/.kube/config` di vm-k8s)

Ambil kubeconfig dari vm-k8s (jalankan dari vm-docker):

```bash
scp cikal@192.168.56.43:~/.kube/config ./kubeconfig-prod
```

Upload file itu ke variable `KUBECONFIG_PROD` (Type: File).

### ✅ ADD-ON 3 (tempel tepat sebelum `E2) Push pertama`)

> Tujuan: bikin “gate” terakhir supaya kamu **tidak push** kalau Harbor belum siap (biar pipeline pertama tidak gagal lagi).

```bash
# =========================================================
# ADD-ON: FINAL PRE-FLIGHT SEBELUM PUSH PERTAMA KE GITLAB
# Tempel tepat sebelum E2 (Push pertama)
# =========================================================

echo "=== FINAL CHECK: Harbor harus hidup & reachable ==="
curl -fsSI http://harbor.local:8080/v2/ | head -n 1 || (
  echo "ERROR: Harbor tidak reachable di http://harbor.local:8080"
  echo "Pastikan: Harbor containers UP, port 8080 LISTEN, dan UFW tidak blok."
  exit 1
)

echo "=== FINAL CHECK: project 'threebody' sudah dibuat di UI Harbor ==="
echo "Buka: http://harbor.local:8080/ lalu pastikan project threebody ada."
```

## ✅ ADD-ON A (Wajib untuk 3 VM kosong): “Bootstrap ImagePull Secret di K8S sebelum pipeline pertama”

Kenapa perlu? Karena yang bikin kamu gagal kemarin adalah:

* di namespace baru, SA/secret bisa belum siap / beda nama (`harbor-pull` vs `harbor-regcred`)

Dengan ADD-ON ini, sebelum push pertama kamu “mengunci” kondisi cluster supaya **selaras** dengan `.gitlab-ci.yml`.

**Tempel di runbook di bagian E1 (GitLab Variables), setelah kamu upload `KUBECONFIG_PROD`, sebelum E2 Push pertama.**

```bash
# =========================================================
# ADD-ON: K8S BOOTSTRAP IMAGEPULL (sekali saja sebelum pipeline pertama)
# Jalankan di vm-k8s
# =========================================================
NS=threebody-prod
SECRET=harbor-regcred

echo "=== namespace ==="
kubectl get ns "$NS" >/dev/null 2>&1 || kubectl create ns "$NS"

echo "=== serviceaccount default ==="
kubectl -n "$NS" get sa default >/dev/null 2>&1 || kubectl -n "$NS" create sa default

echo "=== create/refresh secret $SECRET ==="
kubectl -n "$NS" create secret docker-registry "$SECRET" \
  --docker-server="harbor.local:8080" \
  --docker-username="admin" \
  --docker-password="Harbor12345" \
  --dry-run=client -o yaml | kubectl apply -f -

echo "=== attach ke SA default ==="
kubectl -n "$NS" patch sa default --type merge \
  -p '{"imagePullSecrets":[{"name":"'"$SECRET"'"}]}'

echo "=== verifikasi ==="
kubectl -n "$NS" get secret "$SECRET" -o name
kubectl -n "$NS" get sa default -o jsonpath='{.imagePullSecrets[*].name}'; echo
```

> Kalau kamu nanti pakai username/password Harbor dari GitLab Variables (bukan hardcode), kamu bisa jalankan bootstrap ini setelah kamu yakin kredensial Harbor benar. Tapi untuk runbook “sekali push lab”, ini yang paling stabil.

#### ✅ ADD-ON LARAVEL READY (wajib)

**Tempatkan:** di runbook **B4 (setelah unzip repo & sebelum E2 Push pertama)**

```bash
# =========================================================
# ADD-ON: FIX LARAVEL APACHE DOCROOT (WAJIB sebelum push pertama)
# Lokasi: vm-docker, setelah repo siap, sebelum git push pertama
# =========================================================
cd ~/three-body-problem

echo "=== cek Dockerfile Laravel sudah set APACHE_DOCUMENT_ROOT ke /public ==="
grep -n "APACHE_DOCUMENT_ROOT" -n laravel/Dockerfile || true
grep -n "laravel.conf" -n laravel/Dockerfile || true

echo "Jika belum ada APACHE_DOCUMENT_ROOT=/var/www/html/public, lakukan FULL REPLACE laravel/Dockerfile sesuai runbook."
```

### E2) Push pertama

Di vm-docker (repo sudah ada):

```bash
cd ~/three-body-problem

git init
git config --global init.defaultBranch main
git config --global user.name "cikalfarid"
git config --global user.email "cikalfarid@users.noreply.gitlab.com"
git branch -M main

git remote remove origin 2>/dev/null || true
git remote add origin git@gitlab-443:cikalfarid/three-body-problem.git
git remote -v

git add -A
git commit -m "init: ci + k8s + edge + harbor" || true
git push -u origin main --force
```

> **Penting:** jangan ubah YAML jadi `:${TAG}` karena Kubernetes **tidak** melakukan substitusi `${TAG}`.\
> Di project kamu sudah benar: manifest pakai `:latest`, lalu pipeline **`kubectl set image ...:$CI_COMMIT_SHORT_SHA`**.

#### ✅ ADD-ON LARAVEL SMOKE TEST (wajib)

**Tempatkan:** di runbook **setelah pipeline deploy sukses** (misal setelah ringkasan deploy / healthcheck)

```bash
# =========================================================
# ADD-ON: SMOKE TEST LARAVEL & GO VIA EDGE
# Lokasi: vm-docker (setelah deploy sukses)
# =========================================================
curl -kfsS --resolve hit.local:443:127.0.0.1 https://hit.local/go/api/products | head
curl -kfsS --resolve hit.local:443:127.0.0.1 https://hit.local/laravel/api/products | head
```

Target: dua-duanya balik JSON (bukan HTML Apache 404/403).

***

## F. Setelah deploy sukses (sekali saja): migrate/seed

Di vm-k8s:

```bash
NS=threebody-prod
LARAVEL_POD=$(kubectl -n "$NS" get pod -l app=laravel -o jsonpath='{.items[0].metadata.name}')
kubectl -n "$NS" exec -it "$LARAVEL_POD" -- php artisan migrate --force
kubectl -n "$NS" exec -it "$LARAVEL_POD" -- php artisan db:seed --force || true
```

#### ✅ ADD-ON SEED POLICY (biar data tidak dobel)

Masalah “5 jadi 10” itu **normal** karena `db:seed` kamu tidak idempotent.

**Tempatkan:** di runbook **F (migrate/seed)**

```bash
# =========================================================
# ADD-ON: SEED JANGAN DIJALANKAN BERULANG
# - php artisan db:seed jika dijalankan berkali-kali bisa bikin data dobel
# =========================================================
```

**Kalau kamu ingin “reset balik ke 5” (lab)**

Tambahkan juga ini di bagian F sebagai opsi:

```bash
# =========================================================
# ADD-ON: LAB RESET DATA (balikin kondisi awal seed)
# WARNING: hapus & buat ulang table + seed ulang (untuk lab)
# =========================================================
NS=threebody-prod
LARAVEL_POD=$(kubectl -n "$NS" get pod -l app=laravel -o jsonpath='{.items[0].metadata.name}')
kubectl -n "$NS" exec -it "$LARAVEL_POD" -- php artisan migrate:fresh --seed --force
```

***

## G. Catatan khusus soal “image Laravel besar”

Dari data kamu sebelumnya: **content size \~242MB** (disk usage besar karena layer/cache lokal Docker). Kalau kamu mau kecilkan lagi, itu bisa—tapi **aku sarankan lakukan setelah “sekali push aman” dulu** supaya tidak nambah risiko di push pertama.

Kalau kamu mau, aku bisa kasih patch yang aman step-by-step untuk Laravel Dockerfile (multi-stage lebih ketat + purge build deps), tapi tetap aku sarankan jadi tahap **optimasi setelah sistem stabil**.

***

### File project

Kamu sekarang pakai `three-body-problem-final.zip`. Kalau kamu mau versi yang sudah aku tambah:

* root `.dockerignore` (biar build context lebih bersih)
* `laravel/Dockerfile.slim` (opsional untuk optimasi size)

Aku bisa kasih juga, tapi kalau targetmu “push pertama wajib aman”, pakai yang sekarang dulu (karena sudah terbukti jalan).

Kalau kamu lanjut dari kondisi “vm kosong”, kamu tinggal ikuti runbook di atas **urut A → B → C → D → E**.

Kalau kamu mau, kirim 2 output ini saat nanti sudah sampai tahap kubernetes:

1. `kubectl get nodes -o wide`
2. `kubectl -n threebody-prod get pods -o wide`\
   biar aku cek cepat apakah sudah 100% sesuai sebelum kamu push pertama.
