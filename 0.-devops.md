# 0. DevOps

Berikut **runbook step-by-step (urut, detail, ramah pemula)** untuk skenario 4 VM kamu (NAT + Host-Only), sampai **jalan di VM docker**, punya **Harbor (multistage image)**, **deploy ke Docker + Kubernetes**, pakai **GitLab CI/CD + Secret (GitLab Variables)**, **HTTPS + rate-limiting**, **logging terintegrasi ke Grafana**, plus **dokumen sistem-design DRC**.

> Catatan konteks repo: React di **3000**, Laravel API di **8001**, Go API di **8080**. ([GitHub](https://github.com/cikal-farid/three-body-problem-main))

***

### 0) Gambaran Arsitektur Target

**VM & IP (Host-Only 192.168.56.0/24):**

* **VM docker** — `192.168.56.42` — RAM 2GB (jalanin staging docker compose + GitLab Runner)
* **VM harbor** — `192.168.56.43` — RAM 2GB (registry image)
* **VM kubernetes (control-plane)** — `192.168.56.44` — RAM 6GB
* **VM worker** — `192.168.56.45` — RAM 2GB

**Flow CI/CD:**\
GitLab push → Pipeline build+test → build image **multistage** → push ke **Harbor** →\
Deploy **Staging (Docker Compose) di VM docker** + healthcheck →\
Deploy **Production (Kubernetes) di VM k8s** + rollout/healthcheck →\
Semua log masuk ke **Loki + Grafana**.

***

### 1) Setup Host-Only Network (di Laptop/Host kamu)

Kalau pakai VirtualBox:

1. Buka **File → Host Network Manager**
2. Buat host-only network: `vboxnet0`
3. Set:
   * IPv4: `192.168.56.1`
   * DHCP: boleh **OFF** (lebih rapi pakai static di VM)

Di setiap VM nanti pasang **2 adapter**:

* Adapter 1: **NAT** (buat internet)
* Adapter 2: **Host-Only** (vboxnet0)

***

### 2) Install Ubuntu & Set Hostname (semua VM)

Pakai Ubuntu Server 22.04/24.04 (bebas). Setelah login:

#### 2.1 Set hostname

Jalankan sesuai VM:

```bash
sudo hostnamectl set-hostname docker
# atau: harbor / kubernetes / worker
```

#### 2.2 Update paket dasar

Di semua VM:

```bash
sudo apt update && sudo apt -y upgrade
sudo apt -y install curl wget git vim ca-certificates gnupg lsb-release net-tools jq
```

#### 2.3 Matikan swap (wajib untuk Kubernetes)

Di **VM kubernetes** dan **VM worker**:

```bash
sudo swapoff -a
sudo sed -i.bak '/\sswap\s/s/^/#/' /etc/fstab
```

***

### 3) Konfigurasi IP Static Host-Only (penting!)

Biasanya:

* NAT: `enp0s3` (DHCP)
* Host-only: `enp0s8` (STATIC)

Cek nama interface:

```bash
ip a
```

Edit netplan:

```bash
sudo ls /etc/netplan/
sudo nano /etc/netplan/01-netcfg.yaml
```

Contoh **VM docker (192.168.56.42)**:

```yaml
network:
  version: 2
  ethernets:
    enp0s3:
      dhcp4: true
    enp0s8:
      dhcp4: false
      addresses: [192.168.56.42/24]
```

Ulangi untuk VM lain (ubah IP):

* harbor → `192.168.56.43/24`
* kubernetes → `192.168.56.44/24`
* worker → `192.168.56.45/24`

Apply:

```bash
sudo netplan apply
```

Test ping antar VM:

```bash
ping -c 3 192.168.56.43
ping -c 3 192.168.56.44
ping -c 3 192.168.56.45
```

***

### 4) Set `/etc/hosts` (biar gampang akses pakai nama)

Di **SEMUA VM** (dan kalau bisa juga di laptop/host), tambahkan:

```bash
sudo nano /etc/hosts
```

Isi:

```txt
192.168.56.43 harbor.local
192.168.56.44 k8s.local
192.168.56.42 docker.local

192.168.56.44 frontend.threebody.local
192.168.56.44 laravel.threebody.local
192.168.56.44 go.threebody.local
192.168.56.44 grafana.threebody.local
```

***

## BAGIAN A — VM HARBOR (192.168.56.43)

### 5) Install Docker di VM Harbor

```bash
sudo apt update
sudo apt -y install docker.io docker-compose-plugin
sudo usermod -aG docker $USER
newgrp docker
docker version
docker compose version
```

### 6) Install Harbor (pakai HTTPS self-signed biar aman)

**6.1 Download Harbor offline installer**\
Ambil versi terbaru dari release Harbor (boleh lewat browser), lalu pindahkan ke VM harbor. Setelah file ada di VM:

```bash
tar -xzf harbor-offline-installer-*.tgz
cd harbor
```

**6.2 Buat sertifikat self-signed untuk `harbor.local`**

```bash
mkdir -p certs
openssl req -x509 -nodes -days 3650 -newkey rsa:2048 \
  -keyout certs/harbor.key -out certs/harbor.crt \
  -subj "/CN=harbor.local" \
  -addext "subjectAltName=DNS:harbor.local,IP:192.168.56.43"
```

**6.3 Edit `harbor.yml`**

```bash
cp harbor.yml.tmpl harbor.yml
nano harbor.yml
```

Set minimal:

```yaml
hostname: harbor.local

https:
  port: 443
  certificate: /your/path/harbor/certs/harbor.crt
  private_key: /your/path/harbor/certs/harbor.key

harbor_admin_password: Harbor12345
```

**6.4 Install**

```bash
sudo ./prepare
sudo ./install.sh
docker compose ps
```

Coba buka:

* `https://harbor.local` (di laptop/host, pastikan hosts sudah di-set)

```
https://harbor.local
```

***

## BAGIAN B — VM DOCKER (192.168.56.42) – RUN PROJECT (staging docker)

### 7) Install Docker + tools (VM docker)

```bash
sudo apt -y install docker.io docker-compose-plugin
sudo usermod -aG docker $USER
newgrp docker
```

### 8) Trust sertifikat Harbor di VM docker (wajib agar bisa `docker pull/push`)

Salin `harbor.crt` dari VM harbor ke VM docker (pakai scp):

```bash
# dari VM docker:
mkdir -p /tmp/harbor-certs
scp cikal@192.168.56.43:/home/cikal/harbor/certs/harbor.crt /tmp/harbor-certs/ca.crt
```

Pasang CA untuk Docker:

```bash
sudo mkdir -p /etc/docker/certs.d/harbor.local
sudo cp /tmp/harbor-certs/ca.crt /etc/docker/certs.d/harbor.local/ca.crt
sudo systemctl restart docker
```

Login:

```bash
docker login harbor.local
```

***

### 9) Clone repo & jalankan lokal (versi docker compose)

```bash
cd ~
git clone https://github.com/cikal-farid/three-body-problem-main.git
cd three-body-problem-main
```

Repo menjelaskan port defaultnya: Laravel 8001, Go 8080, React 3000. ([GitHub](https://github.com/cikal-farid/three-body-problem-main))

#### 9.1 Buat file `docker-compose.staging.yml`

Di root repo:

```bash
nano docker-compose.staging.yml
```

Contoh yang simpel (staging):

```yaml
services:
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    volumes:
      - mysql_data:/var/lib/mysql
    healthcheck:
      test: ["CMD-SHELL", "MYSQL_PWD=$$MYSQL_ROOT_PASSWORD mysqladmin ping -h 127.0.0.1 --protocol=tcp -uroot --silent"]
      interval: 5s
      timeout: 5s
      retries: 40

  laravel:
    image: harbor.local/threebody/laravel:${TAG}
    environment:
      APP_ENV: production
      APP_DEBUG: "false"
      APP_KEY: ${LARAVEL_APP_KEY}
      DB_CONNECTION: mysql
      DB_HOST: mysql
      DB_PORT: "3306"
      DB_DATABASE: ${MYSQL_DATABASE}
      DB_USERNAME: ${MYSQL_USER}
      DB_PASSWORD: ${MYSQL_PASSWORD}
    depends_on:
      mysql:
        condition: service_healthy
    ports:
      - "8001:8001"

  go:
    image: harbor.local/threebody/go:${TAG}
    environment:
      DB_HOST: mysql
      DB_PORT: "3306"
      DB_NAME: ${MYSQL_DATABASE}
      DB_USER: ${MYSQL_USER}
      DB_PASS: ${MYSQL_PASSWORD}
    depends_on:
      mysql:
        condition: service_healthy
    ports:
      - "8080:8080"

  frontend:
    image: harbor.local/threebody/frontend:${TAG}
    ports:
      - "3000:80"
    depends_on:
      - laravel
      - go

volumes:
  mysql_data:
```

> Nanti image `TAG` akan diisi dari GitLab CI. Untuk test manual, kamu bisa set `TAG=dev` dan build lokal dulu.

***

## BAGIAN C — MULTISTAGE DOCKERFILE (image kecil + siap Harbor)

> Ini inti “image Laravel kecil”: **alpine + multistage + hanya runtime deps**.

### 10) Buat Dockerfile multistage

#### 10.1 `laravel/Dockerfile`

```dockerfile
# syntax=docker/dockerfile:1

FROM composer:2 AS vendor
WORKDIR /app
COPY laravel/composer.json laravel/composer.lock ./
RUN composer install --no-dev --prefer-dist --no-interaction --no-progress --optimize-autoloader
COPY laravel/ .
RUN composer dump-autoload --optimize

FROM php:8.2-cli-alpine AS runtime
WORKDIR /app

# runtime libs
RUN apk add --no-cache icu-libs libzip \
 && apk add --no-cache --virtual .build-deps $PHPIZE_DEPS icu-dev libzip-dev oniguruma-dev \
 && docker-php-ext-install pdo_mysql intl zip mbstring \
 && apk del .build-deps

COPY --from=vendor /app /app
EXPOSE 8001

CMD ["php","artisan","serve","--host=0.0.0.0","--port=8001"]
```

> Catatan: `apk` itu **khusus Alpine di Dockerfile**, bukan di Ubuntu host. Kalau kamu jalanin `apk add` di Ubuntu akan error (normal).

#### 10.2 `go/Dockerfile`

```dockerfile
FROM golang:1.22-alpine AS build
WORKDIR /src
COPY go/go.mod go/go.sum ./
RUN go mod download
COPY go/ .
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o /out/go-api .

FROM gcr.io/distroless/static-debian12:nonroot
COPY --from=build /out/go-api /go-api
EXPOSE 8080
USER nonroot:nonroot
ENTRYPOINT ["/go-api"]
```

#### 10.3 `frontend/Dockerfile`

```dockerfile
FROM node:20-alpine AS build
WORKDIR /app
COPY frontend/package*.json ./
RUN npm ci
COPY frontend/ .
RUN npm run build

FROM nginx:1.27-alpine
COPY --from=build /app/build /usr/share/nginx/html
EXPOSE 80
```

***

## BAGIAN D — KUBERNETES CLUSTER (192.168.56.44 + 45)

### 11) Install K3s (paling gampang untuk pemula)

#### 11.1 Control-plane di VM kubernetes (192.168.56.44)

```bash
curl -sfL https://get.k3s.io | sh -s - \
  --write-kubeconfig-mode 644 \
  --node-ip 192.168.56.44 \
  --disable traefik
```

Cek:

```bash
sudo kubectl get nodes
```

Ambil token join:

```bash
sudo cat /var/lib/rancher/k3s/server/node-token
```

#### 11.2 Worker join (VM worker 192.168.56.45)

```bash
curl -sfL https://get.k3s.io | K3S_URL=https://192.168.56.44:6443 K3S_TOKEN="ISI_TOKEN_DARI_SERVER" sh -s - \
  --node-ip 192.168.56.45
```

Cek dari control-plane:

```bash
sudo kubectl get nodes -o wide
```

***

### 12) Agar Kubernetes bisa pull image dari Harbor HTTPS self-signed

Di **VM kubernetes** dan **VM worker**:

1. salin CA cert harbor:

```bash
sudo mkdir -p /etc/rancher/k3s/harbor
sudo scp cikal@192.168.56.43:/path/harbor/certs/harbor.crt /etc/rancher/k3s/harbor/ca.crt
```

2. buat registries config:

```bash
sudo nano /etc/rancher/k3s/registries.yaml
```

Isi:

```yaml
mirrors:
  "harbor.local":
    endpoint:
      - "https://harbor.local"
configs:
  "harbor.local":
    tls:
      ca_file: /etc/rancher/k3s/harbor/ca.crt
```

Restart k3s:

```bash
sudo systemctl restart k3s
# di worker:
sudo systemctl restart k3s-agent
```

***

## BAGIAN E — INGRESS NGINX + HTTPS + RATE LIMITING

### 13) Install ingress-nginx (NodePort)

Di VM kubernetes:

```bash
sudo kubectl create namespace ingress-nginx
sudo kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/baremetal/deploy.yaml
```

Tunggu siap:

```bash
sudo kubectl -n ingress-nginx get pods -w
```

### 14) Buat TLS secret (self-signed)

```bash
mkdir -p ~/tls && cd ~/tls
openssl req -x509 -nodes -days 3650 -newkey rsa:2048 \
  -keyout threebody.key -out threebody.crt \
  -subj "/CN=frontend.threebody.local" \
  -addext "subjectAltName=DNS:frontend.threebody.local,DNS:laravel.threebody.local,DNS:go.threebody.local,DNS:grafana.threebody.local,IP:192.168.56.44"
```

Nanti secret dibuat di namespace app (contoh `threebody`).

***

## BAGIAN F — DEPLOY APP KE KUBERNETES

### 15) Buat namespace + secret DB + secret TLS

```bash
sudo kubectl create namespace threebody
sudo kubectl -n threebody create secret tls threebody-tls --key ~/tls/threebody.key --cert ~/tls/threebody.crt
```

Secret DB (contoh):

```bash
sudo kubectl -n threebody create secret generic mysql-secret \
  --from-literal=MYSQL_ROOT_PASSWORD='RootPass!' \
  --from-literal=MYSQL_DATABASE='threebody' \
  --from-literal=MYSQL_USER='threebody' \
  --from-literal=MYSQL_PASSWORD='UserPass!'
```

### 16) Deploy MySQL (paling sederhana)

Buat `k8s/mysql.yaml`:

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
  namespace: threebody
spec:
  accessModes: ["ReadWriteOnce"]
  resources:
    requests:
      storage: 5Gi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
  namespace: threebody
spec:
  selector:
    matchLabels: {app: mysql}
  template:
    metadata:
      labels: {app: mysql}
    spec:
      containers:
        - name: mysql
          image: mysql:8.0
          ports:
            - containerPort: 3306
          env:
            - name: MYSQL_ROOT_PASSWORD
              valueFrom: {secretKeyRef: {name: mysql-secret, key: MYSQL_ROOT_PASSWORD}}
            - name: MYSQL_DATABASE
              valueFrom: {secretKeyRef: {name: mysql-secret, key: MYSQL_DATABASE}}
            - name: MYSQL_USER
              valueFrom: {secretKeyRef: {name: mysql-secret, key: MYSQL_USER}}
            - name: MYSQL_PASSWORD
              valueFrom: {secretKeyRef: {name: mysql-secret, key: MYSQL_PASSWORD}}
          volumeMounts:
            - name: data
              mountPath: /var/lib/mysql
      volumes:
        - name: data
          persistentVolumeClaim:
            claimName: mysql-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: mysql
  namespace: threebody
spec:
  selector: {app: mysql}
  ports:
    - port: 3306
      targetPort: 3306
```

Apply:

```bash
sudo kubectl apply -f k8s/mysql.yaml
```

### 17) Deploy Laravel + Go + Frontend (image dari Harbor)

Buat `k8s/apps.yaml` (contoh minimal, ganti `:TAG` nanti dari CI):

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: laravel
  namespace: threebody
spec:
  replicas: 1
  selector: {matchLabels: {app: laravel}}
  template:
    metadata: {labels: {app: laravel}}
    spec:
      containers:
        - name: laravel
          image: harbor.local/threebody/laravel:TAG
          ports: [{containerPort: 8001}]
          env:
            - name: APP_ENV
              value: "production"
            - name: APP_DEBUG
              value: "false"
            - name: APP_KEY
              valueFrom: {secretKeyRef: {name: laravel-secret, key: APP_KEY}}
            - name: DB_CONNECTION
              value: "mysql"
            - name: DB_HOST
              value: "mysql"
            - name: DB_PORT
              value: "3306"
            - name: DB_DATABASE
              valueFrom: {secretKeyRef: {name: mysql-secret, key: MYSQL_DATABASE}}
            - name: DB_USERNAME
              valueFrom: {secretKeyRef: {name: mysql-secret, key: MYSQL_USER}}
            - name: DB_PASSWORD
              valueFrom: {secretKeyRef: {name: mysql-secret, key: MYSQL_PASSWORD}}
---
apiVersion: v1
kind: Service
metadata:
  name: laravel
  namespace: threebody
spec:
  selector: {app: laravel}
  ports:
    - port: 8001
      targetPort: 8001
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: go
  namespace: threebody
spec:
  replicas: 1
  selector: {matchLabels: {app: go}}
  template:
    metadata: {labels: {app: go}}
    spec:
      containers:
        - name: go
          image: harbor.local/threebody/go:TAG
          ports: [{containerPort: 8080}]
---
apiVersion: v1
kind: Service
metadata:
  name: go
  namespace: threebody
spec:
  selector: {app: go}
  ports:
    - port: 8080
      targetPort: 8080
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: threebody
spec:
  replicas: 1
  selector: {matchLabels: {app: frontend}}
  template:
    metadata: {labels: {app: frontend}}
    spec:
      containers:
        - name: frontend
          image: harbor.local/threebody/frontend:TAG
          ports: [{containerPort: 80}]
---
apiVersion: v1
kind: Service
metadata:
  name: frontend
  namespace: threebody
spec:
  selector: {app: frontend}
  ports:
    - port: 80
      targetPort: 80
```

Laravel APP\_KEY secret:

```bash
sudo kubectl -n threebody create secret generic laravel-secret --from-literal=APP_KEY='base64:ISI_APP_KEY'
```

> APP\_KEY bisa kamu generate dari lokal: `php artisan key:generate --show` lalu paste ke GitLab Variable.

***

### 18) Ingress HTTPS + Rate Limiting

Buat `k8s/ingress.yaml`:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: threebody
  namespace: threebody
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/limit-rps: "5"
    nginx.ingress.kubernetes.io/limit-burst-multiplier: "3"
spec:
  ingressClassName: nginx
  tls:
    - hosts:
        - frontend.threebody.local
        - laravel.threebody.local
        - go.threebody.local
      secretName: threebody-tls
  rules:
    - host: frontend.threebody.local
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service: {name: frontend, port: {number: 80}}
    - host: laravel.threebody.local
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service: {name: laravel, port: {number: 8001}}
    - host: go.threebody.local
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service: {name: go, port: {number: 8080}}
```

Apply:

```bash
sudo kubectl apply -f k8s/ingress.yaml
```

Test dari VM kubernetes:

```bash
curl -k https://laravel.threebody.local/api/products
curl -k https://go.threebody.local/api/products
curl -k https://frontend.threebody.local
```

***

## BAGIAN G — LOGGING TERINTEGRASI (Loki + Grafana)

### 19) Install Loki + Grafana (helm paling gampang)

Di VM kubernetes:

```bash
curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
helm repo add grafana https://grafana.github.io/helm-charts
helm repo update
kubectl create namespace monitoring
```

Install Loki stack:

```bash
helm install loki grafana/loki-stack -n monitoring \
  --set grafana.enabled=true \
  --set promtail.enabled=true
```

Ambil password grafana:

```bash
kubectl -n monitoring get secret loki-grafana -o jsonpath="{.data.admin-password}" | base64 -d; echo
```

Expose Grafana via NodePort (biar bisa dibuka dari host-only):

```bash
kubectl -n monitoring patch svc loki-grafana -p '{"spec":{"type":"NodePort","ports":[{"port":80,"targetPort":3000,"nodePort":30080}]}}'
```

Akses:

* `http://grafana.threebody.local:30080` (user: `admin`, pass dari secret)

> Promtail di cluster otomatis ambil log semua pod → Loki → tampil di Grafana.

***

## BAGIAN H — GITLAB CI/CD + SECRET MANAGER (GitLab Variables)

### 20) Push ke GitLab + set variables

Di GitLab project → Settings → CI/CD → Variables (mask & protect kalau perlu)

Wajib:

* `HARBOR_URL=harbor.local`
* `HARBOR_PROJECT=threebody`
* `HARBOR_USERNAME=admin` (atau robot account)
* `HARBOR_PASSWORD=...`
* `MYSQL_ROOT_PASSWORD=...`
* `MYSQL_DATABASE=threebody`
* `MYSQL_USER=threebody`
* `MYSQL_PASSWORD=...`
* `LARAVEL_APP_KEY=base64:...`

Untuk deploy k8s:

* `KUBECONFIG_B64` = base64 dari kubeconfig yang sudah diganti servernya ke `https://192.168.56.44:6443`

Cara buat KUBECONFIG:

```bash
sudo cat /etc/rancher/k3s/k3s.yaml > /tmp/kubeconfig.yaml
sudo sed -i 's/127.0.0.1/192.168.56.44/' /tmp/kubeconfig.yaml
base64 -w0 /tmp/kubeconfig.yaml
```

***

### 21) Install GitLab Runner di VM docker (shell executor, paling gampang)

Di VM docker:

```bash
curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash
sudo apt -y install gitlab-runner
sudo gitlab-runner register
```

Isi saat register:

* URL GitLab: (punyamu)
* Token: (dari GitLab → Settings → CI/CD → Runners)
* Executor: `shell`
* Tags: `deploy`

***

### 22) `.gitlab-ci.yml` (build + test + push + deploy docker + deploy k8s + healthcheck)

Buat `.gitlab-ci.yml` di root repo:

```yaml
stages: [test, build, push, deploy_staging, deploy_prod, verify]

variables:
  DOCKER_BUILDKIT: "1"

test:
  stage: test
  tags: ["deploy"]
  script:
    - echo "Optional: jalanin test kalau ada"
    - test -f go/go.mod && (cd go && go test ./... || true)
    - test -f laravel/artisan && (cd laravel && php -v || true)
    - test -f compare_apis.sh && bash compare_apis.sh || true

build_push:
  stage: push
  tags: ["deploy"]
  script:
    - : "${HARBOR_URL:?}" "${HARBOR_PROJECT:?}" "${HARBOR_USERNAME:?}" "${HARBOR_PASSWORD:?}"
    - TAG="${CI_COMMIT_SHA}"
    - REG="${HARBOR_URL}/${HARBOR_PROJECT}"

    - docker login "${HARBOR_URL}" -u "${HARBOR_USERNAME}" -p "${HARBOR_PASSWORD}"

    - docker build -f laravel/Dockerfile -t "${REG}/laravel:${TAG}" .
    - docker build -f go/Dockerfile      -t "${REG}/go:${TAG}" .
    - docker build -f frontend/Dockerfile -t "${REG}/frontend:${TAG}" .

    - docker push "${REG}/laravel:${TAG}"
    - docker push "${REG}/go:${TAG}"
    - docker push "${REG}/frontend:${TAG}"

deploy_staging:
  stage: deploy_staging
  tags: ["deploy"]
  script:
    - export TAG="${CI_COMMIT_SHA}"
    - export MYSQL_ROOT_PASSWORD MYSQL_DATABASE MYSQL_USER MYSQL_PASSWORD LARAVEL_APP_KEY
    - export LARAVEL_APP_KEY="${LARAVEL_APP_KEY}"
    - docker compose -f docker-compose.staging.yml pull
    - docker compose -f docker-compose.staging.yml up -d
    - docker compose -f docker-compose.staging.yml ps

deploy_prod:
  stage: deploy_prod
  tags: ["deploy"]
  script:
    - echo "${KUBECONFIG_B64}" | base64 -d > kubeconfig.yaml
    - export KUBECONFIG="$PWD/kubeconfig.yaml"

    - TAG="${CI_COMMIT_SHA}"
    - REG="${HARBOR_URL}/${HARBOR_PROJECT}"

    - kubectl -n threebody create secret generic mysql-secret --dry-run=client -o yaml \
        --from-literal=MYSQL_ROOT_PASSWORD="${MYSQL_ROOT_PASSWORD}" \
        --from-literal=MYSQL_DATABASE="${MYSQL_DATABASE}" \
        --from-literal=MYSQL_USER="${MYSQL_USER}" \
        --from-literal=MYSQL_PASSWORD="${MYSQL_PASSWORD}" | kubectl apply -f -

    - kubectl -n threebody create secret generic laravel-secret --dry-run=client -o yaml \
        --from-literal=APP_KEY="${LARAVEL_APP_KEY}" | kubectl apply -f -

    - sed "s/:TAG/:${TAG}/g" k8s/apps.yaml | kubectl apply -f -
    - kubectl apply -f k8s/mysql.yaml
    - kubectl apply -f k8s/ingress.yaml

    - kubectl -n threebody rollout status deploy/mysql --timeout=180s || true
    - kubectl -n threebody rollout status deploy/laravel --timeout=180s
    - kubectl -n threebody rollout status deploy/go --timeout=180s
    - kubectl -n threebody rollout status deploy/frontend --timeout=180s

verify:
  stage: verify
  tags: ["deploy"]
  script:
    - curl -k --max-time 10 https://laravel.threebody.local/api/products
    - curl -k --max-time 10 https://go.threebody.local/api/products
    - curl -k --max-time 10 https://frontend.threebody.local
```

***

## BAGIAN I — DOKUMENTASI SISTEM DESIGN DRC (isi untuk README)

Masukkan ke `README.md` (ringkas tapi “kena”):

**Tujuan DRC**

* Menjamin layanan bisa pulih bila site utama down.
* Target contoh: **RPO 15 menit**, **RTO 1 jam** (silakan sesuaikan).

**Komponen yang harus diproteksi**

* MySQL (data produk)
* Harbor (image registry)
* GitLab (repo + CI config)
* Kubernetes manifests / Helm values
* Grafana/Loki (opsional tapi bagus untuk audit)

**Strategi**

1. **Backup MySQL**
   * Harian full + incremental (atau harian saja)
   * Simpan ke storage terpisah (NFS/S3/minio di DRC)
   * Uji restore berkala
2. **Harbor Replication**
   * Setup replication rule ke Harbor di site DRC (jika ada)
3. **Kubernetes**
   * Semua manifest disimpan di Git (source of truth)
   * PVC backup (opsional) atau restore dari dump DB
4. **Failover plan**
   * Jika site utama mati: jalankan MySQL restore → deploy manifest ke cluster DRC → update DNS/hosts → verifikasi healthcheck.
5. **Runbook DRC**
   * Langkah restore DB
   * Langkah redeploy app
   * Validasi endpoint & observability

***

## BAGIAN J — Checklist Screenshot buat Submission

Ambil screenshot:

1. Harbor UI: project `threebody` + daftar image tags
2. GitLab pipeline sukses (semua stage hijau)
3. `docker compose ps` di VM docker (staging)
4. `kubectl get pods -A` (production)
5. Browser:
   * `https://frontend.threebody.local`
   * Grafana dashboard + Explore logs (Loki)

***

Kalau kamu mau, di step berikutnya aku bisa bantu **rapihin struktur folder `k8s/` + bikin README.md final** yang tinggal kamu commit ke GitLab (termasuk arsitektur, runbook singkat, dan section DRC), tapi panduan di atas sudah cukup untuk kamu eksekusi berurutan.
