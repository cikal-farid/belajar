# 0. DevOps V3.1

Siap. Aku **sudah ekstrak ZIP** yang kamu kirim dan aku cek strukturnya. Di dalam ZIP itu memang ada:

* `.gitlab-ci.yml` di root (sesuai yang kamu paste)
* `deploy/k8s/base/*.yaml` (dipakai pipeline)
* `deploy/edge/*` (edge nginx + cert + conf)
* `deploy/staging/*` (staging compose)
* `deploy/k8s/jobs/*` (ada, tapi **tidak dipakai** oleh pipeline kamu saat ini)
* `frontend/src/App.js` sudah **full replace** versi yang aman (pakai env `REACT_APP_*`)

Di bawah ini aku bagi 2 bagian:

1. **Komentar/audit** (apa yang kurang/bentrok/tidak terpakai)
2. **Runbook versi rapi per-VM** (copy/paste, dari 4 VM kosong → siap push GitLab)

***

### 1) Komentar/Audit runbook kamu (fokus biar pipeline pertama langsung aman)

#### A. Folder `deploy/k8s/base` itu **WAJIB** dan memang dipakai

Di `.gitlab-ci.yml` kamu ada:

```bash
kubectl apply -f deploy/k8s/base/
kubectl -n "$K8S_NS_PROD" set image deployment/frontend ...
kubectl -n "$K8S_NS_PROD" set image deployment/go ...
kubectl -n "$K8S_NS_PROD" set image deployment/laravel ...
```

Jadi **folder `deploy/k8s/base` harus ada** dan isinya harus bikin resource bernama:

* namespace: `threebody-prod`
* deployment: `frontend`, `go`, `laravel`
* service NodePort: 30080/30081/30082

✅ Di ZIP kamu, semuanya ada dan match.

***

#### B. Potensi “bentrok” paling penting: **nama imagePullSecret**

Di YAML K8s kamu (di ZIP) pod memakai:

```yaml
imagePullSecrets:
  - name: harbor-pull
```

Tapi di `.gitlab-ci.yml` default-nya:

```yaml
K8S_IMAGEPULL_SECRET: "harbor-regcred"
```

Kalau kamu bikin cluster **baru dari nol**, mismatch ini bisa bikin **ImagePullBackOff** (pod minta secret `harbor-pull`, tapi pipeline bikin `harbor-regcred`).

✅ Cara beres TANPA ubah `.gitlab-ci.yml`:\
**Set variable GitLab** `K8S_IMAGEPULL_SECRET` = `harbor-pull` (override nilai di YAML).\
Jadi pipeline akan bikin secret **harbor-pull** dan semuanya konsisten.

***

#### C. `deploy/k8s/jobs/laravel-migrate-job.yaml` saat ini **tidak dipakai pipeline**

Pipeline kamu tidak apply file job itu, jadi:

* migrate/seed tidak otomatis jalan
* aplikasi bisa “kelihatan hidup” (frontend OK), tapi API bisa error kalau DB belum migrate

➡️ Solusi aman (tanpa ubah `.gitlab-ci.yml`): setelah pipeline pertama sukses, kamu jalankan **sekali** migrate/seed manual via `kubectl exec` (aku masukin di runbook).

***

#### D. Bagian runbook yang bisa “dibuang” untuk versi minimal

Karena kamu bilang observability nanti dulu dan mau yang tidak terpakai dibuang, maka untuk runbook minimal yang fokus pipeline:

* Observability Loki/Grafana/Promtail → **hapus dulu**
* `KUBECONFIG_B64` → **tidak perlu** (pipeline kamu pakai `KUBECONFIG_PROD` type File)
* `EDGE_TLS_CRT/EDGE_TLS_KEY` → **tidak perlu** untuk pipeline (di ZIP cert edge sudah ada di `deploy/edge/certs/`)

***

### 2) RUNBOOK RAPI PER-VM (4 VM kosong → normal → siap push GitLab)

Target IP (sesuai rancangan kamu):

* vm-docker: `192.168.56.42`
* vm-harbor: `192.168.56.43`
* vm-k8s: `192.168.56.44`
* vm-worker: `192.168.56.45`

> **Urutan eksekusi yang paling aman:**
>
> 1. vm-harbor → 2) vm-k8s → 3) vm-worker → 4) vm-docker → push GitLab

***

### HARDEN semua VM: matikan auto update & cegah restart service otomatis

> Jalankan di **SEMUA VM**: `vm-docker`, `vm-harbor`, `vm-k8s`, `vm-worker`

```bash
sudo systemctl stop unattended-upgrades 2>/dev/null || true
sudo systemctl disable --now unattended-upgrades 2>/dev/null || true

sudo systemctl stop apt-daily.service apt-daily-upgrade.service 2>/dev/null || true
sudo systemctl disable --now apt-daily.timer apt-daily-upgrade.timer 2>/dev/null || true

# rapikan dpkg kalau pernah kepotong
sudo dpkg --configure -a || true
```

Kalau file needrestart ada, set supaya **tidak auto-restart service**:

```bash
if [ -f /etc/needrestart/needrestart.conf ]; then
  sudo cp -a /etc/needrestart/needrestart.conf /etc/needrestart/needrestart.conf.bak.$(date +%F-%H%M%S)
  sudo sed -i "s/^\s*\$nrconf{restart}.*/\$nrconf{restart} = 'l';/" /etc/needrestart/needrestart.conf || true
fi
```

> Mode `'l'` = cuma list, **tidak restart service** otomatis.

## VM-1: `vm-harbor` (Registry Harbor + TLS + auto start)

### 1. Set hostname + hosts

```bash
sudo hostnamectl set-hostname vm-harbor

sudo tee /etc/hosts >/dev/null <<'EOF'
127.0.0.1 localhost
192.168.56.42 vm-docker staging.local prod.local
192.168.56.43 vm-harbor harbor.local
192.168.56.44 vm-k8s
192.168.56.45 vm-worker
EOF

getent hosts harbor.local staging.local prod.local
```

### 2. Paket dasar + SSH + UFW (jangan sampai scp timeout)

```bash
sudo apt-get update -y
sudo apt-get install -y ca-certificates curl git nano openssh-server ufw openssl

sudo systemctl enable --now ssh

sudo ufw allow OpenSSH
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
sudo ufw status verbose || true

# pastikan default outgoing allow (di lab ini aman)
sudo ufw default allow outgoing || true

# optional: allow spesifik ke API server
sudo ufw allow out to 192.168.56.44 port 6443 proto tcp || true

sudo ufw --force enable
sudo ufw status
```

### 3. Install Docker + Compose

```bash
curl -fsSL https://get.docker.com | sudo sh
sudo usermod -aG docker "$USER"
newgrp docker

docker version
docker compose version
```

***

✅ Solusi paling aman & cepat: **hentikan proses auto-upgrade yang ngunci dpkg**, rapikan state dpkg, lalu ulang install Docker.

Silakan **copy–paste persis** di `vm-harbor`:

```bash
# 1) Matikan service auto-update yang lagi ngunci apt/dpkg
sudo systemctl stop unattended-upgrades.service apt-daily.service apt-daily-upgrade.service || true

# 2) Kill proses yang pegang lock (sesuai log kamu: PID 2941)
sudo kill -9 2941 2>/dev/null || true

# 3) Hapus file lock (kalau masih ada)
sudo rm -f /var/lib/dpkg/lock-frontend /var/lib/dpkg/lock /var/cache/apt/archives/lock

# 4) Bereskan dpkg/apt yang mungkin setengah jalan
sudo dpkg --configure -a
sudo apt-get -f install -y
sudo apt-get update -y
```

Lalu **install Docker ulang** (copy–paste):

```bash
curl -fsSL https://get.docker.com | sudo sh

# pastikan group docker ada (kadang belum kebentuk kalau install gagal sebelumnya)
getent group docker >/dev/null || sudo groupadd docker

sudo usermod -aG docker "$USER"
newgrp docker

docker version
docker compose version
```

Kalau `docker version` sudah keluar normal, berarti `vm-harbor` beres dan kita bisa lanjut step Harbor installer.

***

### 4. Install Harbor (offline installer) + TLS

> Kamu boleh pakai versi yang kamu biasa pakai. Ini contoh `v2.14.1`.

```bash
export HARBOR_VERSION="v2.14.1"

cd /tmp
wget -O "harbor-offline-installer-${HARBOR_VERSION}.tgz" \
  "https://github.com/goharbor/harbor/releases/download/${HARBOR_VERSION}/harbor-offline-installer-${HARBOR_VERSION}.tgz"

tar -xzf "harbor-offline-installer-${HARBOR_VERSION}.tgz"

sudo rm -rf /opt/harbor
sudo mv harbor /opt/harbor
sudo chown -R "$USER:$USER" /opt/harbor
```

#### 4.1 Buat CA + cert `harbor.local`

```bash
sudo mkdir -p /etc/harbor/certs
cd /etc/harbor/certs

sudo openssl genrsa -out ca.key 4096
sudo openssl req -x509 -new -nodes -sha512 -days 3650 \
  -subj "/C=ID/ST=Jakarta/L=Jakarta/O=Lab/OU=DevOps/CN=lab-ca" \
  -key ca.key -out ca.crt

sudo openssl genrsa -out harbor.local.key 4096
sudo openssl req -new -sha512 \
  -subj "/C=ID/ST=Jakarta/L=Jakarta/O=Lab/OU=DevOps/CN=harbor.local" \
  -key harbor.local.key -out harbor.local.csr

cat | sudo tee v3.harbor.ext >/dev/null <<'EOF'
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
DNS.1=harbor.local
IP.1=192.168.56.43
EOF

sudo openssl x509 -req -sha512 -days 3650 \
  -in harbor.local.csr \
  -CA ca.crt -CAkey ca.key -CAcreateserial \
  -out harbor.local.crt \
  -extfile v3.harbor.ext

openssl x509 -in harbor.local.crt -noout -subject -issuer
```

#### 4.2 Konfig `harbor.yml` + install

```bash
cd /opt/harbor
cp harbor.yml.tmpl harbor.yml

nano harbor.yml
```

Isi minimal seperti ini (wajib hostname benar):

```yaml
hostname: harbor.local

http:
  port: 80

https:
  port: 443
  certificate: /etc/harbor/certs/harbor.local.crt
  private_key: /etc/harbor/certs/harbor.local.key

harbor_admin_password: Harbor12345
data_volume: /data/harbor
```

Lanjut:

```bash
sudo mkdir -p /data/harbor
sudo chown -R "$USER:$USER" /data/harbor

cd /opt/harbor
sudo ./install.sh

sudo docker compose -f /opt/harbor/docker-compose.yml ps
curl -kI https://harbor.local | head
```

### 5. Systemd `harbor.service` (biar reboot aman)

```bash
sudo tee /etc/systemd/system/harbor.service >/dev/null <<'EOF'
[Unit]
Description=Harbor Registry (Docker Compose)
After=network-online.target docker.service
Wants=network-online.target docker.service

[Service]
Type=oneshot
RemainAfterExit=yes
WorkingDirectory=/opt/harbor
ExecStart=/usr/bin/docker compose -f /opt/harbor/docker-compose.yml up -d --remove-orphans
ExecStop=/usr/bin/docker compose -f /opt/harbor/docker-compose.yml stop
TimeoutStartSec=0

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl daemon-reload
sudo systemctl enable --now harbor
sudo systemctl status harbor --no-pager -l
```

### 6. Buat project + robot account Harbor

Di UI `https://harbor.local`:

```
https://harbor.local
```

* Projects → New Project → `threebody`
* Simpan:

NAME :

```
gitlab-ci
```

### 7. Siapkan file CA untuk dibagikan ke VM lain

```bash
ls -lah /etc/harbor/certs/ca.crt
```

***

## VM-2: `vm-k8s` (Kubernetes control-plane kubeadm)

### 1. Hostname + hosts

```bash
sudo hostnamectl set-hostname vm-k8s

sudo tee /etc/hosts >/dev/null <<'EOF'
127.0.0.1 localhost
192.168.56.42 vm-docker staging.local prod.local
192.168.56.43 vm-harbor harbor.local
192.168.56.44 vm-k8s
192.168.56.45 vm-worker
EOF

getent hosts harbor.local
```

### 2. Paket dasar

```bash
sudo apt-get update -y
sudo apt-get install -y ca-certificates curl nano openssh-server
sudo systemctl enable --now ssh
```

### 3. (Recommended) Matikan UFW di node K8s (biar lab stabil)

```bash
sudo ufw disable || true
```

### 4. Disable swap

```bash
sudo swapoff -a
sudo sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
```

### 5. Install containerd + systemd cgroup

```bash
sudo apt-get install -y containerd

sudo mkdir -p /etc/containerd
containerd config default | sudo tee /etc/containerd/config.toml >/dev/null
sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/' /etc/containerd/config.toml

sudo systemctl enable --now containerd
sudo systemctl restart containerd
```

### 6. Kernel modules + sysctl (wajib)

```bash
cat <<'EOF' | sudo tee /etc/modules-load.d/k8s.conf >/dev/null
overlay
br_netfilter
EOF

sudo modprobe overlay
sudo modprobe br_netfilter

cat <<'EOF' | sudo tee /etc/sysctl.d/99-kubernetes.conf >/dev/null
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF

sudo sysctl --system
```

### 7. Install kubeadm/kubelet/kubectl (v1.30)

```bash
sudo apt-get install -y apt-transport-https ca-certificates curl gpg

sudo mkdir -p -m 0755 /etc/apt/keyrings
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key \
  | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg

echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] \
https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /" \
  | sudo tee /etc/apt/sources.list.d/kubernetes.list

sudo apt-get update -y
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl
```

### 8. Trust CA Harbor untuk containerd (ambil dari vm-harbor)

### 8.0 Reset config containerd (WAJIB kalau pernah pakai step lama yang ada “perl”)

> Ini aman walau dijalankan berulang. Ini juga “menghapus” efek config yang rusak.

```bash
# stop dulu
sudo systemctl stop containerd || true

# backup config lama (opsional, tapi aman)
sudo cp -a /etc/containerd/config.toml "/etc/containerd/config.toml.bak.$(date +%F-%H%M%S)" 2>/dev/null || true

# generate config default fresh
sudo mkdir -p /etc/containerd
containerd config default | sudo tee /etc/containerd/config.toml >/dev/null

# wajib: systemd cgroup (buat kubeadm di Ubuntu modern)
sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/' /etc/containerd/config.toml

# wajib: aktifkan config_path untuk registry certs.d (TANPA PERL)
sudo awk '
/^\[plugins\."io\.containerd\.grpc\.v1\.cri"\.registry\]$/ && !done {
  print
  print "  config_path = \"/etc/containerd/certs.d\""
  done=1
  next
}
{print}
' /etc/containerd/config.toml | sudo tee /etc/containerd/config.toml.new >/dev/null
sudo mv /etc/containerd/config.toml.new /etc/containerd/config.toml

# start lagi
sudo systemctl enable --now containerd
sudo systemctl restart containerd

# pastikan running
sudo systemctl is-active containerd
```

Kalau output terakhir `active` → lanjut.

***

### 8.1 Copy CA dari vm-harbor + buat hosts.toml (AMAN)

> **PENTING:** setelah ini **JANGAN ADA** command `perl -0777 ...` lagi ya.

```bash
scp cikal@192.168.56.43:/etc/harbor/certs/ca.crt /tmp/harbor-ca.crt

# trust OS
sudo cp /tmp/harbor-ca.crt /usr/local/share/ca-certificates/harbor.local.crt
sudo update-ca-certificates

# trust containerd (wajib)
sudo mkdir -p /etc/containerd/certs.d/harbor.local
sudo cp /tmp/harbor-ca.crt /etc/containerd/certs.d/harbor.local/ca.crt

sudo tee /etc/containerd/certs.d/harbor.local/hosts.toml >/dev/null <<'EOF'
server = "https://harbor.local"

[host."https://harbor.local"]
  capabilities = ["pull", "resolve"]
  ca = "/etc/containerd/certs.d/harbor.local/ca.crt"
EOF

sudo systemctl restart containerd
sudo systemctl is-active containerd
```

Kalau output `active` → berarti step trust CA sudah “kepasang” dan containerd tetap sehat.

***

### 8.2 (Opsional tapi bagus) Hilangkan warning `crictl default endpoints`

Ini tidak wajib, tapi biar output kamu bersih:

```bash
sudo tee /etc/crictl.yaml >/dev/null <<'EOF'
runtime-endpoint: unix:///run/containerd/containerd.sock
image-endpoint: unix:///run/containerd/containerd.sock
timeout: 10
debug: false
EOF

sudo crictl info | head
```

***

### 8.3 Validasi TLS ke Harbor (yang penting tidak ada x509 error)

```bash
curl -vk https://harbor.local/v2/ 2>&1 | tail -n 25
```

✅ Hasil yang “benar” biasanya **401 Unauthorized** (wajar karena butuh login), yang penting **TIDAK ADA** error:

* `SSL certificate problem`
* `x509: certificate signed by unknown authority`

### 9. Init cluster

```bash
sudo kubeadm init \
  --apiserver-advertise-address=192.168.56.44 \
  --apiserver-cert-extra-sans=192.168.56.44,vm-k8s \
  --pod-network-cidr=192.168.0.0/16
```

Set kubectl user:

```bash
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
kubectl get nodes
```

Install CNI (Calico):

```bash
kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.28.0/manifests/calico.yaml
watch -n 2 -d 'kubectl get nodes'
```

Ambil join command (buat worker):

```bash
kubeadm token create --print-join-command --ttl 24h
```

***

## VM-3: `vm-worker` (Kubernetes worker)

### 1. Hostname + hosts

```bash
sudo hostnamectl set-hostname vm-worker

sudo tee /etc/hosts >/dev/null <<'EOF'
127.0.0.1 localhost
192.168.56.42 vm-docker staging.local prod.local
192.168.56.43 vm-harbor harbor.local
192.168.56.44 vm-k8s
192.168.56.45 vm-worker
EOF
```

### 2. Paket dasar + matikan UFW

```bash
sudo apt-get update -y
sudo apt-get install -y ca-certificates curl nano openssh-server
sudo systemctl enable --now ssh
sudo ufw disable || true
```

### 3. Disable swap

```bash
sudo swapoff -a
sudo sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
```

### 4. Install containerd + systemd cgroup

```bash
sudo apt-get install -y containerd

sudo mkdir -p /etc/containerd
containerd config default | sudo tee /etc/containerd/config.toml >/dev/null

# wajib untuk kubeadm
sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/' /etc/containerd/config.toml

sudo systemctl enable --now containerd
sudo systemctl restart containerd
sudo systemctl is-active containerd
```

Jika ada kendala dpkg lock jalankan perintah dibawah ini

```
# lihat siapa yang pegang lock
ps -fp 2170 || true
pgrep -a unattended-upgrade || true
pgrep -a apt.systemd.daily || true

# tunggu sampai prosesnya selesai (maks 10 menit, cek tiap 5 detik)
for i in {1..120}; do
  if sudo fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1; then
    echo "dpkg lock masih dipakai... ($i)"
    sleep 5
  else
    echo "dpkg lock sudah lepas"
    break
  fi
done

# rapikan kalau ada install yang kepotong
sudo dpkg --configure -a
sudo apt-get -f install -y
sudo apt-get update -y
```

### 5. Kernel modules + sysctl

```bash
cat <<'EOF' | sudo tee /etc/modules-load.d/k8s.conf >/dev/null
overlay
br_netfilter
EOF
sudo modprobe overlay
sudo modprobe br_netfilter

cat <<'EOF' | sudo tee /etc/sysctl.d/99-kubernetes.conf >/dev/null
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF
sudo sysctl --system
```

### 6. Install kubeadm/kubelet/kubectl

```bash
sudo apt-get install -y apt-transport-https ca-certificates curl gpg
sudo mkdir -p -m 0755 /etc/apt/keyrings
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key \
  | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] \
https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /" \
  | sudo tee /etc/apt/sources.list.d/kubernetes.list
sudo apt-get update -y
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl
```

### 7. Trust CA Harbor untuk containerd (ambil dari vm-harbor)

### 7.0 Reset config containerd (WAJIB kalau pernah pakai step lama yang ada “perl”)

> Ini aman walau dijalankan berulang. Ini juga “menghapus” efek config yang rusak.

```bash
# stop dulu
sudo systemctl stop containerd || true

# backup config lama (opsional, tapi aman)
sudo cp -a /etc/containerd/config.toml "/etc/containerd/config.toml.bak.$(date +%F-%H%M%S)" 2>/dev/null || true

# generate config default fresh
sudo mkdir -p /etc/containerd
containerd config default | sudo tee /etc/containerd/config.toml >/dev/null

# wajib: systemd cgroup (buat kubeadm di Ubuntu modern)
sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/' /etc/containerd/config.toml

# wajib: aktifkan config_path untuk registry certs.d (TANPA PERL)
sudo awk '
/^\[plugins\."io\.containerd\.grpc\.v1\.cri"\.registry\]$/ && !done {
  print
  print "  config_path = \"/etc/containerd/certs.d\""
  done=1
  next
}
{print}
' /etc/containerd/config.toml | sudo tee /etc/containerd/config.toml.new >/dev/null
sudo mv /etc/containerd/config.toml.new /etc/containerd/config.toml

# start lagi
sudo systemctl enable --now containerd
sudo systemctl restart containerd

# pastikan running
sudo systemctl is-active containerd
```

Kalau output terakhir `active` → lanjut.

***

### 7.1 Copy CA dari vm-harbor + buat hosts.toml (AMAN)

> **PENTING:** setelah ini **JANGAN ADA** command `perl -0777 ...` lagi ya.

```bash
# ambil CA dari vm-harbor
scp cikal@192.168.56.43:/etc/harbor/certs/ca.crt /tmp/harbor-ca.crt

# taruh CA ke lokasi yang dibaca containerd
sudo mkdir -p /etc/containerd/certs.d/harbor.local
sudo cp /tmp/harbor-ca.crt /etc/containerd/certs.d/harbor.local/ca.crt

# buat hosts.toml untuk harbor.local
sudo tee /etc/containerd/certs.d/harbor.local/hosts.toml >/dev/null <<'EOF'
server = "https://harbor.local"

[host."https://harbor.local"]
  capabilities = ["pull", "resolve", "push"]
  ca = "/etc/containerd/certs.d/harbor.local/ca.crt"
EOF

# restart containerd
sudo systemctl restart containerd
sudo systemctl is-active containerd
```

Kalau output `active` → berarti step trust CA sudah “kepasang” dan containerd tetap sehat.

***

### 7.2 (Opsional tapi bagus) Hilangkan warning `crictl default endpoints`

Ini tidak wajib, tapi biar output kamu bersih:

```bash
sudo tee /etc/crictl.yaml >/dev/null <<'EOF'
runtime-endpoint: unix:///run/containerd/containerd.sock
image-endpoint: unix:///run/containerd/containerd.sock
timeout: 10
debug: false
EOF

sudo crictl info | head
```

***

### 7.3 Validasi TLS ke Harbor (yang penting tidak ada x509 error)

```bash
curl -vk https://harbor.local/v2/ 2>&1 | tail -n 25
```

✅ Hasil yang “benar” biasanya **401 Unauthorized** (wajar karena butuh login), yang penting **TIDAK ADA** error:

* `SSL certificate problem`
* `x509: certificate signed by unknown authority`

### 8. Join cluster (paste join command dari vm-k8s)

```bash
# PASTE join command dari vm-k8s di sini
# contoh:
# sudo kubeadm join 192.168.56.44:6443 --token ... --discovery-token-ca-cert-hash sha256:...
sebagai contoh dibawah ini
sudo kubeadm join 192.168.56.44:6443 --token 5ccc8f.na65lm39arleiaij --discovery-token-ca-cert-hash sha256:a04ef151627d8ada2355eff4b4298a5057fd55b8fb12575b086b59553ef81a07
```

### 9. Siapkan hostPath MySQL (WAJIB untuk prod)

```bash
sudo mkdir -p /data/threebody/mysql
sudo chown -R 999:999 /data/threebody/mysql || true
sudo chmod 700 /data/threebody/mysql || true
```

***

## VM-4: `vm-docker` (GitLab Runner + Docker build/push + Edge Nginx)

### 1. Hostname + hosts

```bash
sudo hostnamectl set-hostname vm-docker

sudo tee /etc/hosts >/dev/null <<'EOF'
127.0.0.1 localhost
192.168.56.42 vm-docker staging.local prod.local
192.168.56.43 vm-harbor harbor.local
192.168.56.44 vm-k8s
192.168.56.45 vm-worker
EOF

getent hosts harbor.local prod.local
```

### 2. Paket dasar + SSH + UFW

```bash
sudo apt-get update -y
sudo apt-get install -y ca-certificates curl git nano openssh-server ufw unzip rsync

sudo systemctl enable --now ssh

sudo ufw allow OpenSSH
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp

sudo ufw status verbose || true

# pastikan default outgoing allow (di lab ini aman)
sudo ufw default allow outgoing || true

# optional: allow spesifik ke API server
sudo ufw allow out to 192.168.56.44 port 6443 proto tcp || true

sudo ufw --force enable
sudo ufw status
```

### 3. FIX DNS GitLab (systemd-resolved)

```bash
sudo nano /etc/systemd/resolved.conf
```

Isi/aktifkan:

```ini
DNS=1.1.1.1 8.8.8.8
FallbackDNS=9.9.9.9 8.8.4.4
```

Lanjut:

```bash
sudo systemctl restart systemd-resolved
sudo resolvectl flush-caches
resolvectl query altssh.gitlab.com
```

### 4. Install Docker

```bash
curl -fsSL https://get.docker.com | sudo sh
sudo usermod -aG docker "$USER"
newgrp docker

docker version
docker compose version
```

### 5. Trust CA Harbor untuk Docker (WAJIB biar pipeline bisa login/push)

```bash
scp cikal@192.168.56.43:/etc/harbor/certs/ca.crt /tmp/harbor-ca.crt

sudo mkdir -p /etc/docker/certs.d/harbor.local
sudo cp /tmp/harbor-ca.crt /etc/docker/certs.d/harbor.local/ca.crt

sudo cp /tmp/harbor-ca.crt /usr/local/share/ca-certificates/harbor-ca.crt
sudo update-ca-certificates

sudo systemctl restart docker
```

Test TLS (yang penting tidak x509 error):

```bash
curl -v https://harbor.local/v2/ 2>&1 | tail -n 20
```

### 6. Setup SSH key untuk push GitLab via port 443

```bash
ssh-keygen -t ed25519 -C "vm-docker-gitlab" -f ~/.ssh/id_ed25519 -N ""

mkdir -p ~/.ssh

cat <<'EOF' > ~/.ssh/config
Host gitlab-443 gitlab.com-443
  HostName altssh.gitlab.com
  User git
  Port 443
  IdentityFile ~/.ssh/id_ed25519
  IdentitiesOnly yes
  StrictHostKeyChecking accept-new
EOF

chmod 700 ~/.ssh
chmod 600 ~/.ssh/id_ed25519 ~/.ssh/config
chmod 644 ~/.ssh/id_ed25519.pub

ssh-keyscan -p 443 altssh.gitlab.com >> ~/.ssh/known_hosts
chmod 644 ~/.ssh/known_hosts
```

Copy isi pubkey ke GitLab → Profile → SSH Keys:

```bash
cat ~/.ssh/id_ed25519.pub
```

Test:

```bash
ssh -T git@gitlab-443
```

***

### 7. Siapkan source repo: mulai dari GitHub (kosongan) tapi “dibikin sama persis” dengan template ZIP

#### 7.1 Clone GitHub

```bash
cd ~
rm -rf ~/three-body-problem-main
git clone https://github.com/cikal-farid/three-body-problem-main.git
cd ~/three-body-problem-main
```

Buat direktori terlebih dahulu

```bash
cd ~/three-body-problem-main
mkdir -p deploy/edge/nginx/conf.d
mkdir -p deploy/edge/certs
mkdir -p deploy/staging
mkdir -p deploy/k8s/base
```

Buat file

```bash
cd ~/three-body-problem-main
nano deploy/edge/docker-compose.edge.yml
```

Isi file dengan ini :

```bash
services:
  edge-nginx:
    image: nginx:alpine
    container_name: edge-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d:ro
      - ./certs:/etc/nginx/certs:ro
    networks:
      - edge-net
    restart: unless-stopped

networks:
  edge-net:
    name: edge-net
```

Buat file&#x20;

```
nano deploy/edge/nginx/conf.d/edge.conf
```

Isi file dengan ini :

```bash
# rate limiting zone
limit_req_zone $binary_remote_addr zone=api_rl:10m rate=5r/s;

server {
  listen 80;
  server_name staging.local prod.local;
  return 301 https://$host$request_uri;
}

# ---------- STAGING ----------
server {
  listen 443 ssl;
  server_name staging.local;

  ssl_certificate     /etc/nginx/certs/tls.crt;
  ssl_certificate_key /etc/nginx/certs/tls.key;

  # frontend
  location / {
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_pass http://stg-frontend:80;
  }

  # go
  location /go/ {
    limit_req zone=api_rl burst=10 nodelay;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_pass http://stg-go:8080/;
  }

  # laravel
  location /laravel/ {
    limit_req zone=api_rl burst=10 nodelay;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_pass http://stg-laravel:80/;
  }
}

# ---------- PROD (K8s NodePort) ----------
server {
  listen 443 ssl;
  server_name prod.local;

  ssl_certificate     /etc/nginx/certs/tls.crt;
  ssl_certificate_key /etc/nginx/certs/tls.key;

  location / {
    proxy_pass http://192.168.56.45:30080;
  }

  location /go/ {
    limit_req zone=api_rl burst=10 nodelay;
    proxy_pass http://192.168.56.45:30081/;
  }

  location /laravel/ {
    limit_req zone=api_rl burst=10 nodelay;
    proxy_pass http://192.168.56.45:30082/;
  }
}
```

Buat file&#x20;

```
nano deploy/k8s/base/00-namespace.yaml
```

Isi file dengan ini :

```bash
apiVersion: v1
kind: Namespace
metadata:
  name: threebody-prod
```

Buat file&#x20;

```
nano deploy/k8s/base/10-mysql.yaml
```

Isi file dengan ini :

```bash
apiVersion: v1
kind: Service
metadata:
  name: mysql
  namespace: threebody-prod
spec:
  selector:
    app: mysql
  ports:
    - name: mysql
      port: 3306
      targetPort: 3306
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
  namespace: threebody-prod
spec:
  serviceName: mysql
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      nodeSelector:
        kubernetes.io/hostname: vm-worker

      # opsional tapi sangat membantu untuk hostPath PV (permission)
      initContainers:
        - name: init-mysql-perms
          image: busybox:1.36
          command:
            - sh
            - -c
            - |
              mkdir -p /var/lib/mysql
              chown -R 999:999 /var/lib/mysql || true
          volumeMounts:
            - name: mysql-data
              mountPath: /var/lib/mysql

      containers:
        - name: mysql
          image: mysql:8.0
          ports:
            - name: mysql
              containerPort: 3306
          env:
            - name: MYSQL_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: MYSQL_ROOT_PASSWORD
            - name: MYSQL_DATABASE
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: MYSQL_DATABASE
            - name: MYSQL_USER
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: MYSQL_USER
            - name: MYSQL_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: MYSQL_PASSWORD

          volumeMounts:
            - name: mysql-data
              mountPath: /var/lib/mysql

          readinessProbe:
            exec:
              command:
                - sh
                - -c
                - MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysqladmin ping -h 127.0.0.1 -uroot --silent
            initialDelaySeconds: 10
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 30

          livenessProbe:
            exec:
              command:
                - sh
                - -c
                - MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysqladmin ping -h 127.0.0.1 -uroot --silent
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 10

      # ✅ FIX UTAMA: definisikan volume mysql-data (yang dipakai di volumeMounts)
      volumes:
        - name: mysql-data
          persistentVolumeClaim:
            claimName: mysql-data

  # kamu sebelumnya punya ini, aku biarkan agar “model” StatefulSet-nya tetap sama
  volumeClaimTemplates: []
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: mysql-pv-hostpath
spec:
  capacity:
    storage: 5Gi
  accessModes: ["ReadWriteOnce"]
  persistentVolumeReclaimPolicy: Retain
  hostPath:
    path: /data/threebody/mysql
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-data
  namespace: threebody-prod
spec:
  accessModes: ["ReadWriteOnce"]
  resources:
    requests:
      storage: 5Gi
  volumeName: mysql-pv-hostpath
```

Buat file&#x20;

```
nano deploy/k8s/base/30-laravel.yaml
```

Isi file dengan ini :

```bash
apiVersion: v1
kind: Service
metadata:
  name: laravel
  namespace: threebody-prod
spec:
  type: NodePort
  selector:
    app: laravel
  ports:
    - name: http
      port: 80
      targetPort: 80
      nodePort: 30082
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: laravel
  namespace: threebody-prod
spec:
  replicas: 1
  selector:
    matchLabels:
      app: laravel
  template:
    metadata:
      labels:
        app: laravel
    spec:
      imagePullSecrets:
        - name: harbor-pull
      containers:
        - name: laravel
          image: harbor.local/threebody/laravel:latest
          ports:
            - containerPort: 80
          env:
            - name: DB_HOST
              value: mysql
            - name: DB_PORT
              value: "3306"
            - name: DB_DATABASE
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: MYSQL_DATABASE
            - name: DB_USERNAME
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: MYSQL_USER
            - name: DB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: MYSQL_PASSWORD
            - name: APP_KEY
              valueFrom:
                secretKeyRef:
                  name: app-secrets
                  key: LARAVEL_APP_KEY
            - name: APP_ENV
              value: production
            - name: APP_DEBUG
              value: "false"
```

Buat file&#x20;

```
nano deploy/k8s/base/40-frontend.yaml
```

Isi file dengan ini :

```bash
apiVersion: v1
kind: Service
metadata:
  name: frontend
  namespace: threebody-prod
spec:
  type: NodePort
  selector:
    app: frontend
  ports:
    - name: http
      port: 80
      targetPort: 80
      nodePort: 30080
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: threebody-prod
spec:
  replicas: 1
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      imagePullSecrets:
        - name: harbor-pull
      containers:
        - name: frontend
          image: harbor.local/threebody/frontend:latest
          ports:
            - containerPort: 80
```

Buat file&#x20;

```
nano deploy/staging/docker-compose.staging.yml
```

Isi file dengan ini :

```bash
services:
  stg-mysql:
    image: mysql:8.0
    container_name: stg-mysql
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    volumes:
      - stg_mysql_data:/var/lib/mysql
    networks: [edge-net]
    healthcheck:
      test: ["CMD-SHELL", "MYSQL_PWD=$$MYSQL_ROOT_PASSWORD mysqladmin ping -h 127.0.0.1 --protocol=tcp -uroot --silent"]
      interval: 5s
      timeout: 5s
      retries: 40

  stg-go:
    image: ${REGISTRY}/go:${TAG}
    container_name: stg-go
    environment:
      DB_HOST: stg-mysql
      DB_PORT: "3306"
      DB_NAME: ${MYSQL_DATABASE}
      DB_USER: ${MYSQL_USER}
      DB_PASS: ${MYSQL_PASSWORD}
    networks: [edge-net]
    depends_on:
      stg-mysql:
        condition: service_healthy

  stg-laravel:
    image: ${REGISTRY}/laravel:${TAG}
    container_name: stg-laravel
    environment:
      DB_HOST: stg-mysql
      DB_PORT: "3306"
      DB_DATABASE: ${MYSQL_DATABASE}
      DB_USERNAME: ${MYSQL_USER}
      DB_PASSWORD: ${MYSQL_PASSWORD}
      APP_KEY: ${LARAVEL_APP_KEY}
    networks: [edge-net]
    depends_on:
      stg-mysql:
        condition: service_healthy

  stg-frontend:
    image: ${REGISTRY}/frontend:${TAG}
    container_name: stg-frontend
    networks: [edge-net]
    depends_on:
      - stg-go
      - stg-laravel

volumes:
  stg_mysql_data:

networks:
  edge-net:
    external: true
```

Buat file&#x20;

```
nano deploy/k8s/base/00-namespace.yaml
```

Isi file dengan ini :

```bash
apiVersion: v1
kind: Namespace
metadata:
  name: threebody-prod
```

Buat file&#x20;

```
nano deploy/k8s/base/00-namespace.yaml
```

Isi file dengan ini :

```bash
apiVersion: v1
kind: Namespace
metadata:
  name: threebody-prod
```

#### 7.2 Masukkan template ZIP (yang proven aman)

> Kamu tadi sudah punya ZIP. Cara paling gampang: upload ZIP ke vm-docker (scp dari laptop), taruh di `~/three-body-problem-main-main.zip`.\
> Contoh dari laptop:

```bash
# jalankan dari laptop kamu (bukan di vm)
# scp three-body-problem-main-main.zip cikal@192.168.56.42:~/
```

Di vm-docker:

```bash
cd ~
rm -rf ~/threebody-template
mkdir -p ~/threebody-template
unzip -q ~/three-body-problem-main-main.zip -d ~/threebody-template
ls -lah ~/threebody-template
```

#### 7.3 Replace isi repo GitHub dengan isi template (kecuali `.git`)

Ini yang bikin “pasti sama” seperti yang sudah running aman.

```bash
rsync -a --delete --exclude='.git' \
  ~/threebody-template/three-body-problem-main-main/ \
  ~/three-body-problem-main/
```

Verifikasi file penting ada:

```bash
cd ~/three-body-problem-main
ls -lah .gitlab-ci.yml
ls -lah deploy/k8s/base
ls -lah deploy/edge/nginx/conf.d/edge.conf
ls -lah frontend/src/App.js
```

***

### 8. Setup Edge Nginx (prod.local → NodePort K8s)

#### 8.1 Copy edge ke `/opt/threebody/edge`

```bash
sudo mkdir -p /opt/threebody/edge
sudo rsync -a --delete ~/three-body-problem-main/deploy/edge/ /opt/threebody/edge/

cd /opt/threebody/edge
sudo ln -sf docker-compose.edge.yml docker-compose.yml
sudo docker compose up -d
sudo docker ps | grep edge-nginx
```

Test nginx config:

```bash
sudo docker exec -it edge-nginx nginx -t
```

#### 8.2 Systemd `threebody-edge` (auto start saat reboot)

```bash
sudo tee /etc/systemd/system/threebody-edge.service >/dev/null <<'EOF'
[Unit]
Description=Threebody Edge Nginx (Docker Compose)
After=docker.service network-online.target
Wants=network-online.target
Requires=docker.service

[Service]
Type=oneshot
RemainAfterExit=yes
WorkingDirectory=/opt/threebody/edge
ExecStart=/usr/bin/docker compose up -d --remove-orphans
ExecStop=/usr/bin/docker compose down --remove-orphans
TimeoutStartSec=0

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl daemon-reload
sudo systemctl enable --now threebody-edge
sudo systemctl status threebody-edge --no-pager -l
```

***

### 9. Install GitLab Runner (shell) + docker permission

```bash
sudo apt-get update -y
sudo apt-get install -y curl ca-certificates

curl -L "https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh" | sudo bash
sudo apt-get install -y gitlab-runner
sudo systemctl enable --now gitlab-runner
gitlab-runner --version
```

Register runner (ambil token dari GitLab Project → Settings → CI/CD → Runners):

```bash
sudo gitlab-runner register
```

```
# executor: shell
# tags: deploy
# description: vm-docker-runner
```

Fix permission Docker untuk user `gitlab-runner`:

```bash
getent group docker || sudo groupadd docker
sudo usermod -aG docker gitlab-runner

sudo chown root:docker /var/run/docker.sock
sudo chmod 660 /var/run/docker.sock

sudo systemctl restart docker
sudo systemctl restart gitlab-runner

id gitlab-runner
sudo -u gitlab-runner docker ps
```

#### Test manual (harusnya sukses)

```bash
docker login harbor.local
# isi username/password harbor
```

## Checklist “sebelum push” versi runbook (biar gak kejadian lagi)

Kalau nanti kamu mau benar-benar “sekali push”, lakukan ini dulu:

#### (A) di vm-worker

```bash
sudo crictl pull harbor.local/threebody/frontend:59c66b0f
```

#### (B) di vm-k8s

```bash
kubectl get nodes -o wide
kubectl -n threebody-prod get sa default -o yaml | sed -n '1,60p'
kubectl -n threebody-prod get secret | egrep -i "harbor-regcred|harbor-pull"
```

#### (C) di vm-docker (runner host)

```bash
curl -kI https://harbor.local | head
docker login harbor.local
```

Kalau semua ini OK → deploy\_prod hampir pasti aman.

***

## GitLab: langkah terakhir sebelum push pertama (biar pipeline langsung aman)

### 1) Buat project GitLab BLANK (jangan initialize README)

Nama: `three-body-problem-main` (atau sesuai kamu)

### 2) Set GitLab CI/CD Variables (wajib)

GitLab Project → Settings → CI/CD → Variables:

**Wajib:**

* `HARBOR_USERNAME` (robot user)
* `HARBOR_PASSWORD` (robot token)
* `MYSQL_ROOT_PASSWORD`
* `MYSQL_DATABASE`
* `MYSQL_USER`
* `MYSQL_PASSWORD`
* `LARAVEL_APP_KEY` (contoh generate: `echo "base64:$(openssl rand -base64 32)"`)
* `KUBECONFIG_PROD` **Type: File** → paste isi `~/.kube/config` dari `vm-k8s`

**PENTING untuk menghindari mismatch secret:**

* `K8S_IMAGEPULL_SECRET` = `harbor-pull`

> Ini kunci biar cluster baru kamu langsung bisa pull image tanpa ImagePullBackOff.

Ambil kubeconfig dari vm-k8s:

```bash
# jalankan di vm-k8s
cat ~/.kube/config
```

### 3) Add remote + push

Di vm-docker:

```bash
git config --local user.name "Cikal Farid"
git config --local user.email "cikalfarid@gmail.com"
```

```bash
cd ~/three-body-problem-main
git remote -v

# ganti USERNAME kamu:
git remote add gitlab git@gitlab-443:cikalfarid/three-body-problem.git

git remote set-url gitlab git@gitlab-443:cikalfarid/three-body-problem.git
ssh -T git@gitlab-443
git push -u gitlab main

git branch -M main
git add .
git commit -m "init: sync template for pipeline"
git push -u gitlab main
```

```bash
cd ~/three-body-problem-main

git config --local user.name "Cikal Farid"
git config --local user.email "cikalfarid@gmail.com"

git remote add gitlab git@gitlab-443:cikalfarid/three-body-problem.git 2>/dev/null || true
git remote set-url gitlab git@gitlab-443:cikalfarid/three-body-problem.git

ssh -T git@gitlab-443

git add -A
git commit -m "update" || true
git branch -M main

git fetch --prune gitlab
git push -u gitlab main --force-with-lease
```

***

## Setelah push: verifikasi pipeline + verifikasi aplikasi

### A) Verifikasi dari vm-k8s

```bash
kubectl get nodes -o wide
kubectl -n threebody-prod get all -o wide
kubectl -n threebody-prod get svc -o wide
```

### B) Verifikasi dari vm-docker (healthcheck sama seperti pipeline)

```bash
curl -kfsS --resolve prod.local:443:127.0.0.1 https://prod.local/ | head
curl -kfsS --resolve prod.local:443:127.0.0.1 https://prod.local/laravel/api/products | head || true
curl -kfsS --resolve prod.local:443:127.0.0.1 https://prod.local/go/api/products | head || true
```

### Pastikan API server stabil (vm-k8s) dan tidak “refused” lagi

**Di vm-k8s:**

```bash
# pastikan 6443 listen
sudo ss -lntp | grep 6443 || true

# cek kubelet & containerd
sudo systemctl is-active containerd
sudo systemctl is-active kubelet

# cek apakah ada tanda OOM / crash
dmesg -T | egrep -i "oom|killed process|out of memory" || true
df -h
free -h
```

Kalau kamu lihat RAM tinggal sedikit / disk penuh, itu kandidat kuat kenapa apiserver “refused”.

### Pastikan vm-docker selalu bisa reach 192.168.56.44:6443 (runner butuh ini)

**Di vm-docker:**

```bash
ping -c 2 192.168.56.44 || true
curl -k --connect-timeout 3 https://192.168.56.44:6443/healthz || true
ip route get 192.168.56.44 || true
```

Kalau sewaktu-waktu route hilang, biasanya beres dengan restart network service:

```bash
sudo systemctl restart NetworkManager 2>/dev/null || true
sudo systemctl restart systemd-networkd 2>/dev/null || true
sudo systemctl restart systemd-resolved 2>/dev/null || true
```

***

## One-time (biar API Laravel benar-benar “siap”): migrate + seed

> Jalankan sekali setelah deploy pertama sukses.

Di vm-k8s:

```bash
NS=threebody-prod

LARAVEL_POD=$(kubectl -n "$NS" get pod -l app=laravel -o jsonpath='{.items[0].metadata.name}')
echo "LARAVEL_POD=$LARAVEL_POD"

kubectl -n "$NS" exec -it "$LARAVEL_POD" -- php artisan migrate --force
kubectl -n "$NS" exec -it "$LARAVEL_POD" -- php artisan db:seed --force || true
```

**Jalankan di vm-k8s**

```bash
sudo journalctl -u kubelet --since "today" --no-pager | tail -n 120
kubectl get nodes -o wide
kubectl describe node vm-worker | egrep -i "Ready|NotReady|NetworkPluginNotReady|cni|runtime|error|fail" -n || true
```

Dari situ biasanya ketahuan persis: **yang restart network / apiserver** itu siapa, dan **vm-worker NotReady** karena apa.

***
