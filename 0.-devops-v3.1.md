# 0. DevOps V3.1

Siap. Aku **sudah ekstrak ZIP** yang kamu kirim dan aku cek strukturnya. Di dalam ZIP itu memang ada:

* `.gitlab-ci.yml` di root (sesuai yang kamu paste)
* `deploy/k8s/base/*.yaml` (dipakai pipeline)
* `deploy/edge/*` (edge nginx + cert + conf)
* `deploy/staging/*` (staging compose)
* `deploy/k8s/jobs/*` (ada, tapi **tidak dipakai** oleh pipeline kamu saat ini)
* `frontend/src/App.js` sudah **full replace** versi yang aman (pakai env `REACT_APP_*`)

Di bawah ini aku bagi 2 bagian:

1. **Komentar/audit** (apa yang kurang/bentrok/tidak terpakai)
2. **Runbook versi rapi per-VM** (copy/paste, dari 4 VM kosong → siap push GitLab)

***

### 1) Komentar/Audit runbook kamu (fokus biar pipeline pertama langsung aman)

#### A. Folder `deploy/k8s/base` itu **WAJIB** dan memang dipakai

Di `.gitlab-ci.yml` kamu ada:

```bash
kubectl apply -f deploy/k8s/base/
kubectl -n "$K8S_NS_PROD" set image deployment/frontend ...
kubectl -n "$K8S_NS_PROD" set image deployment/go ...
kubectl -n "$K8S_NS_PROD" set image deployment/laravel ...
```

Jadi **folder `deploy/k8s/base` harus ada** dan isinya harus bikin resource bernama:

* namespace: `threebody-prod`
* deployment: `frontend`, `go`, `laravel`
* service NodePort: 30080/30081/30082

✅ Di ZIP kamu, semuanya ada dan match.

***

#### B. Potensi “bentrok” paling penting: **nama imagePullSecret**

Di YAML K8s kamu (di ZIP) pod memakai:

```yaml
imagePullSecrets:
  - name: harbor-pull
```

Tapi di `.gitlab-ci.yml` default-nya:

```yaml
K8S_IMAGEPULL_SECRET: "harbor-regcred"
```

Kalau kamu bikin cluster **baru dari nol**, mismatch ini bisa bikin **ImagePullBackOff** (pod minta secret `harbor-pull`, tapi pipeline bikin `harbor-regcred`).

✅ Cara beres TANPA ubah `.gitlab-ci.yml`:\
**Set variable GitLab** `K8S_IMAGEPULL_SECRET` = `harbor-pull` (override nilai di YAML).\
Jadi pipeline akan bikin secret **harbor-pull** dan semuanya konsisten.

***

#### C. `deploy/k8s/jobs/laravel-migrate-job.yaml` saat ini **tidak dipakai pipeline**

Pipeline kamu tidak apply file job itu, jadi:

* migrate/seed tidak otomatis jalan
* aplikasi bisa “kelihatan hidup” (frontend OK), tapi API bisa error kalau DB belum migrate

➡️ Solusi aman (tanpa ubah `.gitlab-ci.yml`): setelah pipeline pertama sukses, kamu jalankan **sekali** migrate/seed manual via `kubectl exec` (aku masukin di runbook).

***

#### D. Bagian runbook yang bisa “dibuang” untuk versi minimal

Karena kamu bilang observability nanti dulu dan mau yang tidak terpakai dibuang, maka untuk runbook minimal yang fokus pipeline:

* Observability Loki/Grafana/Promtail → **hapus dulu**
* `KUBECONFIG_B64` → **tidak perlu** (pipeline kamu pakai `KUBECONFIG_PROD` type File)
* `EDGE_TLS_CRT/EDGE_TLS_KEY` → **tidak perlu** untuk pipeline (di ZIP cert edge sudah ada di `deploy/edge/certs/`)

***

### 2) RUNBOOK RAPI PER-VM (4 VM kosong → normal → siap push GitLab)

Target IP (sesuai rancangan kamu):

* vm-docker: `192.168.56.42`
* vm-harbor: `192.168.56.43`
* vm-k8s: `192.168.56.44`
* vm-worker: `192.168.56.45`

> **Urutan eksekusi yang paling aman:**
>
> 1. vm-harbor → 2) vm-k8s → 3) vm-worker → 4) vm-docker → push GitLab

***

### HARDEN semua VM: matikan auto update & cegah restart service otomatis

> Jalankan di **SEMUA VM**: `vm-docker`, `vm-harbor`, `vm-k8s`, `vm-worker`

```bash
sudo systemctl stop unattended-upgrades 2>/dev/null || true
sudo systemctl disable --now unattended-upgrades 2>/dev/null || true

sudo systemctl stop apt-daily.service apt-daily-upgrade.service 2>/dev/null || true
sudo systemctl disable --now apt-daily.timer apt-daily-upgrade.timer 2>/dev/null || true

# rapikan dpkg kalau pernah kepotong
sudo dpkg --configure -a || true
```

Kalau file needrestart ada, set supaya **tidak auto-restart service**:

```bash
if [ -f /etc/needrestart/needrestart.conf ]; then
  sudo cp -a /etc/needrestart/needrestart.conf /etc/needrestart/needrestart.conf.bak.$(date +%F-%H%M%S)
  sudo sed -i "s/^\s*\$nrconf{restart}.*/\$nrconf{restart} = 'l';/" /etc/needrestart/needrestart.conf || true
fi
```

> Mode `'l'` = cuma list, **tidak restart service** otomatis.

## VM-1: `vm-harbor` (Registry Harbor + TLS + auto start)

### 1. Set hostname + hosts

```bash
sudo hostnamectl set-hostname vm-harbor

sudo tee /etc/hosts >/dev/null <<'EOF'
127.0.0.1 localhost
192.168.56.42 vm-docker staging.local prod.local
192.168.56.43 vm-harbor harbor.local
192.168.56.44 vm-k8s
192.168.56.45 vm-worker
EOF

getent hosts harbor.local staging.local prod.local
```

### 2. Paket dasar + SSH + UFW (jangan sampai scp timeout)

```bash
sudo apt-get update -y
sudo apt-get install -y ca-certificates curl git nano openssh-server ufw openssl

sudo systemctl enable --now ssh

sudo ufw allow OpenSSH
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
sudo ufw status verbose || true

# pastikan default outgoing allow (di lab ini aman)
sudo ufw default allow outgoing || true

# optional: allow spesifik ke API server
sudo ufw allow out to 192.168.56.44 port 6443 proto tcp || true

sudo ufw --force enable
sudo ufw status
```

### 3. Install Docker + Compose

```bash
curl -fsSL https://get.docker.com | sudo sh
sudo usermod -aG docker "$USER"
newgrp docker

docker version
docker compose version
```

***

✅ Solusi paling aman & cepat: **hentikan proses auto-upgrade yang ngunci dpkg**, rapikan state dpkg, lalu ulang install Docker.

Silakan **copy–paste persis** di `vm-harbor`:

```bash
# 1) Matikan service auto-update yang lagi ngunci apt/dpkg
sudo systemctl stop unattended-upgrades.service apt-daily.service apt-daily-upgrade.service || true

# 2) Kill proses yang pegang lock (sesuai log kamu: PID 2941)
sudo kill -9 2941 2>/dev/null || true

# 3) Hapus file lock (kalau masih ada)
sudo rm -f /var/lib/dpkg/lock-frontend /var/lib/dpkg/lock /var/cache/apt/archives/lock

# 4) Bereskan dpkg/apt yang mungkin setengah jalan
sudo dpkg --configure -a
sudo apt-get -f install -y
sudo apt-get update -y
```

Lalu **install Docker ulang** (copy–paste):

```bash
curl -fsSL https://get.docker.com | sudo sh

# pastikan group docker ada (kadang belum kebentuk kalau install gagal sebelumnya)
getent group docker >/dev/null || sudo groupadd docker

sudo usermod -aG docker "$USER"
newgrp docker

docker version
docker compose version
```

Kalau `docker version` sudah keluar normal, berarti `vm-harbor` beres dan kita bisa lanjut step Harbor installer.

***

### 4. Install Harbor (offline installer) + TLS

> Kamu boleh pakai versi yang kamu biasa pakai. Ini contoh `v2.14.1`.

```bash
export HARBOR_VERSION="v2.14.1"

cd /tmp
wget -O "harbor-offline-installer-${HARBOR_VERSION}.tgz" \
  "https://github.com/goharbor/harbor/releases/download/${HARBOR_VERSION}/harbor-offline-installer-${HARBOR_VERSION}.tgz"

tar -xzf "harbor-offline-installer-${HARBOR_VERSION}.tgz"

sudo rm -rf /opt/harbor
sudo mv harbor /opt/harbor
sudo chown -R "$USER:$USER" /opt/harbor
```

#### 4.1 Buat CA + cert `harbor.local`

```bash
sudo mkdir -p /etc/harbor/certs
cd /etc/harbor/certs

sudo openssl genrsa -out ca.key 4096
sudo openssl req -x509 -new -nodes -sha512 -days 3650 \
  -subj "/C=ID/ST=Jakarta/L=Jakarta/O=Lab/OU=DevOps/CN=lab-ca" \
  -key ca.key -out ca.crt

sudo openssl genrsa -out harbor.local.key 4096
sudo openssl req -new -sha512 \
  -subj "/C=ID/ST=Jakarta/L=Jakarta/O=Lab/OU=DevOps/CN=harbor.local" \
  -key harbor.local.key -out harbor.local.csr

cat | sudo tee v3.harbor.ext >/dev/null <<'EOF'
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
DNS.1=harbor.local
IP.1=192.168.56.43
EOF

sudo openssl x509 -req -sha512 -days 3650 \
  -in harbor.local.csr \
  -CA ca.crt -CAkey ca.key -CAcreateserial \
  -out harbor.local.crt \
  -extfile v3.harbor.ext

openssl x509 -in harbor.local.crt -noout -subject -issuer
```

#### 4.2 Konfig `harbor.yml` + install

```bash
cd /opt/harbor
cp harbor.yml.tmpl harbor.yml

nano harbor.yml
```

Isi minimal seperti ini (wajib hostname benar):

```yaml
hostname: harbor.local

http:
  port: 80

https:
  port: 443
  certificate: /etc/harbor/certs/harbor.local.crt
  private_key: /etc/harbor/certs/harbor.local.key

harbor_admin_password: Harbor12345
data_volume: /data/harbor
```

Lanjut:

```bash
sudo mkdir -p /data/harbor
sudo chown -R "$USER:$USER" /data/harbor

cd /opt/harbor
sudo ./install.sh

sudo docker compose -f /opt/harbor/docker-compose.yml ps
curl -kI https://harbor.local | head
```

### 5. Systemd `harbor.service` (biar reboot aman)

```bash
sudo tee /etc/systemd/system/harbor.service >/dev/null <<'EOF'
[Unit]
Description=Harbor Registry (Docker Compose)
After=network-online.target docker.service
Wants=network-online.target docker.service

[Service]
Type=oneshot
RemainAfterExit=yes
WorkingDirectory=/opt/harbor
ExecStart=/usr/bin/docker compose -f /opt/harbor/docker-compose.yml up -d --remove-orphans
ExecStop=/usr/bin/docker compose -f /opt/harbor/docker-compose.yml stop
TimeoutStartSec=0

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl daemon-reload
sudo systemctl enable --now harbor
sudo systemctl status harbor --no-pager -l
```

### 6. Buat project + robot account Harbor

Di UI `https://harbor.local`:

```
https://harbor.local
```

* Projects → New Project → `threebody`
* Robot Accounts → New Robot → kasih izin **Pull+Push**

1. Isi:
   * **Name**: `gitlab-ci` (bebas, tapi rapi)
   * **Expiration**: misal 90 hari / 1 tahun (sesuai kebutuhan)
   * **Permissions**: pilih repository dalam project `threebody`:
     * ✅ **Pull**
     * ✅ **Push**
     * (Tidak perlu Delete / Admin)
2. Klik **Add / Save**
3. Harbor akan menampilkan:
   * **Robot Username** (contoh format biasanya mirip `robot$threebody+gitlab-ci`)
   * **Robot Token/Secret** (sekali tampil, **copy & simpan**)

> Catatan: format username robot kadang beda antar versi Harbor. **Yang penting:** pakai **username persis** yang ditampilkan di UI Harbor.

* Simpan:

NAME :

```
gitlab-ci
```

* `HARBOR_USERNAME` (robot user)

```
HARBOR_USERNAME
```

* `HARBOR_PASSWORD` (robot token)

```
HARBOR_PASSWORD
```

### 7. Siapkan file CA untuk dibagikan ke VM lain

```bash
ls -lah /etc/harbor/certs/ca.crt
```

***

## VM-2: `vm-k8s` (Kubernetes control-plane kubeadm)

### 1. Hostname + hosts

```bash
sudo hostnamectl set-hostname vm-k8s

sudo tee /etc/hosts >/dev/null <<'EOF'
127.0.0.1 localhost
192.168.56.42 vm-docker staging.local prod.local
192.168.56.43 vm-harbor harbor.local
192.168.56.44 vm-k8s
192.168.56.45 vm-worker
EOF

getent hosts harbor.local
```

### 2. Paket dasar

```bash
sudo apt-get update -y
sudo apt-get install -y ca-certificates curl nano openssh-server
sudo systemctl enable --now ssh
```

### 3. (Recommended) Matikan UFW di node K8s (biar lab stabil)

```bash
sudo ufw disable || true
```

### 4. Disable swap

```bash
sudo swapoff -a
sudo sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
```

### 5. Install containerd + systemd cgroup

```bash
sudo apt-get install -y containerd

sudo mkdir -p /etc/containerd
containerd config default | sudo tee /etc/containerd/config.toml >/dev/null
sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/' /etc/containerd/config.toml

sudo systemctl enable --now containerd
sudo systemctl restart containerd
```

### 6. Kernel modules + sysctl (wajib)

```bash
cat <<'EOF' | sudo tee /etc/modules-load.d/k8s.conf >/dev/null
overlay
br_netfilter
EOF

sudo modprobe overlay
sudo modprobe br_netfilter

cat <<'EOF' | sudo tee /etc/sysctl.d/99-kubernetes.conf >/dev/null
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF

sudo sysctl --system
```

### 7. Install kubeadm/kubelet/kubectl (v1.30)

```bash
sudo apt-get install -y apt-transport-https ca-certificates curl gpg

sudo mkdir -p -m 0755 /etc/apt/keyrings
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key \
  | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg

echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] \
https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /" \
  | sudo tee /etc/apt/sources.list.d/kubernetes.list

sudo apt-get update -y
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl
```

### 8. Trust CA Harbor untuk containerd (ambil dari vm-harbor)

### 8.0 Reset config containerd (WAJIB kalau pernah pakai step lama yang ada “perl”)

> Ini aman walau dijalankan berulang. Ini juga “menghapus” efek config yang rusak.

```bash
# stop dulu
sudo systemctl stop containerd || true

# backup config lama (opsional, tapi aman)
sudo cp -a /etc/containerd/config.toml "/etc/containerd/config.toml.bak.$(date +%F-%H%M%S)" 2>/dev/null || true

# generate config default fresh
sudo mkdir -p /etc/containerd
containerd config default | sudo tee /etc/containerd/config.toml >/dev/null

# wajib: systemd cgroup (buat kubeadm di Ubuntu modern)
sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/' /etc/containerd/config.toml

# wajib: aktifkan config_path untuk registry certs.d (TANPA PERL)
sudo awk '
/^\[plugins\."io\.containerd\.grpc\.v1\.cri"\.registry\]$/ && !done {
  print
  print "  config_path = \"/etc/containerd/certs.d\""
  done=1
  next
}
{print}
' /etc/containerd/config.toml | sudo tee /etc/containerd/config.toml.new >/dev/null
sudo mv /etc/containerd/config.toml.new /etc/containerd/config.toml

# start lagi
sudo systemctl enable --now containerd
sudo systemctl restart containerd

# pastikan running
sudo systemctl is-active containerd
```

Kalau output terakhir `active` → lanjut.

***

### 8.1 Copy CA dari vm-harbor + buat hosts.toml (AMAN)

> **PENTING:** setelah ini **JANGAN ADA** command `perl -0777 ...` lagi ya.

```bash
# ambil CA dari vm-harbor
scp cikal@192.168.56.43:/etc/harbor/certs/ca.crt /tmp/harbor-ca.crt

# taruh CA ke lokasi yang dibaca containerd
sudo mkdir -p /etc/containerd/certs.d/harbor.local
sudo cp /tmp/harbor-ca.crt /etc/containerd/certs.d/harbor.local/ca.crt

# buat hosts.toml untuk harbor.local
sudo tee /etc/containerd/certs.d/harbor.local/hosts.toml >/dev/null <<'EOF'
server = "https://harbor.local"

[host."https://harbor.local"]
  capabilities = ["pull", "resolve", "push"]
  ca = "/etc/containerd/certs.d/harbor.local/ca.crt"
EOF

# restart containerd
sudo systemctl restart containerd
sudo systemctl is-active containerd
```

Kalau output `active` → berarti step trust CA sudah “kepasang” dan containerd tetap sehat.

***

### 8.2 (Opsional tapi bagus) Hilangkan warning `crictl default endpoints`

Ini tidak wajib, tapi biar output kamu bersih:

```bash
sudo tee /etc/crictl.yaml >/dev/null <<'EOF'
runtime-endpoint: unix:///run/containerd/containerd.sock
image-endpoint: unix:///run/containerd/containerd.sock
timeout: 10
debug: false
EOF

sudo crictl info | head
```

***

### 8.3 Validasi TLS ke Harbor (yang penting tidak ada x509 error)

```bash
curl -vk https://harbor.local/v2/ 2>&1 | tail -n 25
```

✅ Hasil yang “benar” biasanya **401 Unauthorized** (wajar karena butuh login), yang penting **TIDAK ADA** error:

* `SSL certificate problem`
* `x509: certificate signed by unknown authority`

### 9. Init cluster

```bash
sudo kubeadm init \
  --apiserver-advertise-address=192.168.56.44 \
  --apiserver-cert-extra-sans=192.168.56.44,vm-k8s \
  --pod-network-cidr=192.168.0.0/16
```

Set kubectl user:

```bash
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
kubectl get nodes
```

Install CNI (Calico):

```bash
kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.28.0/manifests/calico.yaml
watch -n 2 -d 'kubectl get nodes'
```

Ambil join command (buat worker):

```bash
kubeadm token create --print-join-command --ttl 24h
```

***

## VM-3: `vm-worker` (Kubernetes worker)

### 1. Hostname + hosts

```bash
sudo hostnamectl set-hostname vm-worker

sudo tee /etc/hosts >/dev/null <<'EOF'
127.0.0.1 localhost
192.168.56.42 vm-docker staging.local prod.local
192.168.56.43 vm-harbor harbor.local
192.168.56.44 vm-k8s
192.168.56.45 vm-worker
EOF
```

### 2. Paket dasar + matikan UFW

```bash
sudo apt-get update -y
sudo apt-get install -y ca-certificates curl nano openssh-server
sudo systemctl enable --now ssh
sudo ufw disable || true
```

### 3. Disable swap

```bash
sudo swapoff -a
sudo sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
```

### 4. Install containerd + systemd cgroup

```bash
sudo apt-get install -y containerd

sudo mkdir -p /etc/containerd
containerd config default | sudo tee /etc/containerd/config.toml >/dev/null

# wajib untuk kubeadm
sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/' /etc/containerd/config.toml

sudo systemctl enable --now containerd
sudo systemctl restart containerd
sudo systemctl is-active containerd
```

Jika ada kendala dpkg lock jalankan perintah dibawah ini

```
# lihat siapa yang pegang lock
ps -fp 2170 || true
pgrep -a unattended-upgrade || true
pgrep -a apt.systemd.daily || true

# tunggu sampai prosesnya selesai (maks 10 menit, cek tiap 5 detik)
for i in {1..120}; do
  if sudo fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1; then
    echo "dpkg lock masih dipakai... ($i)"
    sleep 5
  else
    echo "dpkg lock sudah lepas"
    break
  fi
done

# rapikan kalau ada install yang kepotong
sudo dpkg --configure -a
sudo apt-get -f install -y
sudo apt-get update -y
```

### 5. Kernel modules + sysctl

```bash
cat <<'EOF' | sudo tee /etc/modules-load.d/k8s.conf >/dev/null
overlay
br_netfilter
EOF
sudo modprobe overlay
sudo modprobe br_netfilter

cat <<'EOF' | sudo tee /etc/sysctl.d/99-kubernetes.conf >/dev/null
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF
sudo sysctl --system
```

### 6. Install kubeadm/kubelet/kubectl

```bash
sudo apt-get install -y apt-transport-https ca-certificates curl gpg
sudo mkdir -p -m 0755 /etc/apt/keyrings
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key \
  | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] \
https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /" \
  | sudo tee /etc/apt/sources.list.d/kubernetes.list
sudo apt-get update -y
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl
```

### 7. Trust CA Harbor untuk containerd (ambil dari vm-harbor)

### 7.0 Reset config containerd (WAJIB kalau pernah pakai step lama yang ada “perl”)

> Ini aman walau dijalankan berulang. Ini juga “menghapus” efek config yang rusak.

```bash
# stop dulu
sudo systemctl stop containerd || true

# backup config lama (opsional, tapi aman)
sudo cp -a /etc/containerd/config.toml "/etc/containerd/config.toml.bak.$(date +%F-%H%M%S)" 2>/dev/null || true

# generate config default fresh
sudo mkdir -p /etc/containerd
containerd config default | sudo tee /etc/containerd/config.toml >/dev/null

# wajib: systemd cgroup (buat kubeadm di Ubuntu modern)
sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/' /etc/containerd/config.toml

# wajib: aktifkan config_path untuk registry certs.d (TANPA PERL)
sudo awk '
/^\[plugins\."io\.containerd\.grpc\.v1\.cri"\.registry\]$/ && !done {
  print
  print "  config_path = \"/etc/containerd/certs.d\""
  done=1
  next
}
{print}
' /etc/containerd/config.toml | sudo tee /etc/containerd/config.toml.new >/dev/null
sudo mv /etc/containerd/config.toml.new /etc/containerd/config.toml

# start lagi
sudo systemctl enable --now containerd
sudo systemctl restart containerd

# pastikan running
sudo systemctl is-active containerd
```

Kalau output terakhir `active` → lanjut.

***

### 7.1 Copy CA dari vm-harbor + buat hosts.toml (AMAN)

> **PENTING:** setelah ini **JANGAN ADA** command `perl -0777 ...` lagi ya.

```bash
# ambil CA dari vm-harbor
scp cikal@192.168.56.43:/etc/harbor/certs/ca.crt /tmp/harbor-ca.crt

# taruh CA ke lokasi yang dibaca containerd
sudo mkdir -p /etc/containerd/certs.d/harbor.local
sudo cp /tmp/harbor-ca.crt /etc/containerd/certs.d/harbor.local/ca.crt

# buat hosts.toml untuk harbor.local
sudo tee /etc/containerd/certs.d/harbor.local/hosts.toml >/dev/null <<'EOF'
server = "https://harbor.local"

[host."https://harbor.local"]
  capabilities = ["pull", "resolve", "push"]
  ca = "/etc/containerd/certs.d/harbor.local/ca.crt"
EOF

# restart containerd
sudo systemctl restart containerd
sudo systemctl is-active containerd
```

Kalau output `active` → berarti step trust CA sudah “kepasang” dan containerd tetap sehat.

***

### 7.2 (Opsional tapi bagus) Hilangkan warning `crictl default endpoints`

Ini tidak wajib, tapi biar output kamu bersih:

```bash
sudo tee /etc/crictl.yaml >/dev/null <<'EOF'
runtime-endpoint: unix:///run/containerd/containerd.sock
image-endpoint: unix:///run/containerd/containerd.sock
timeout: 10
debug: false
EOF

sudo crictl info | head
```

***

### 7.3 Validasi TLS ke Harbor (yang penting tidak ada x509 error)

```bash
curl -vk https://harbor.local/v2/ 2>&1 | tail -n 25
```

✅ Hasil yang “benar” biasanya **401 Unauthorized** (wajar karena butuh login), yang penting **TIDAK ADA** error:

* `SSL certificate problem`
* `x509: certificate signed by unknown authority`

### 8. Join cluster (paste join command dari vm-k8s)

```bash
# PASTE join command dari vm-k8s di sini
# contoh:
# sudo kubeadm join 192.168.56.44:6443 --token ... --discovery-token-ca-cert-hash sha256:...
sebagai contoh dibawah ini
sudo kubeadm join 192.168.56.44:6443 --token 5ccc8f.na65lm39arleiaij --discovery-token-ca-cert-hash sha256:a04ef151627d8ada2355eff4b4298a5057fd55b8fb12575b086b59553ef81a07
```

### 9. Siapkan hostPath MySQL (WAJIB untuk prod)

```bash
sudo mkdir -p /data/threebody/mysql
sudo chown -R 999:999 /data/threebody/mysql || true
sudo chmod 700 /data/threebody/mysql || true
```

***

## VM-4: `vm-docker` (GitLab Runner + Docker build/push + Edge Nginx)

### 1. Hostname + hosts

```bash
sudo hostnamectl set-hostname vm-docker

sudo tee /etc/hosts >/dev/null <<'EOF'
127.0.0.1 localhost
192.168.56.42 vm-docker staging.local prod.local
192.168.56.43 vm-harbor harbor.local
192.168.56.44 vm-k8s
192.168.56.45 vm-worker
EOF

getent hosts harbor.local prod.local
```

### 2. Paket dasar + SSH + UFW

```bash
sudo apt-get update -y
sudo apt-get install -y ca-certificates curl git nano openssh-server ufw unzip rsync

sudo systemctl enable --now ssh

sudo ufw allow OpenSSH
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp

sudo ufw status verbose || true

# pastikan default outgoing allow (di lab ini aman)
sudo ufw default allow outgoing || true

# optional: allow spesifik ke API server
sudo ufw allow out to 192.168.56.44 port 6443 proto tcp || true

sudo ufw --force enable
sudo ufw status
```

### 3. FIX DNS GitLab (systemd-resolved)

```bash
sudo nano /etc/systemd/resolved.conf
```

Isi/aktifkan:

```ini
DNS=1.1.1.1 8.8.8.8
FallbackDNS=9.9.9.9 8.8.4.4
```

Lanjut:

```bash
sudo systemctl restart systemd-resolved
sudo resolvectl flush-caches
resolvectl query altssh.gitlab.com
```

### 4. Install Docker

```bash
curl -fsSL https://get.docker.com | sudo sh
sudo usermod -aG docker "$USER"
newgrp docker

docker version
docker compose version
```

### 5. Trust CA Harbor untuk Docker (WAJIB biar pipeline bisa login/push)

```bash
scp cikal@192.168.56.43:/etc/harbor/certs/ca.crt /tmp/harbor-ca.crt

sudo mkdir -p /etc/docker/certs.d/harbor.local
sudo cp /tmp/harbor-ca.crt /etc/docker/certs.d/harbor.local/ca.crt

sudo cp /tmp/harbor-ca.crt /usr/local/share/ca-certificates/harbor-ca.crt
sudo update-ca-certificates

sudo systemctl restart docker
```

Test TLS (yang penting tidak x509 error):

```bash
curl -v https://harbor.local/v2/ 2>&1 | tail -n 20
```

### 6. Setup SSH key untuk push GitLab via port 443

```bash
ssh-keygen -t ed25519 -C "vm-docker-gitlab" -f ~/.ssh/id_ed25519 -N ""

mkdir -p ~/.ssh

cat <<'EOF' > ~/.ssh/config
Host gitlab-443 gitlab.com-443
  HostName altssh.gitlab.com
  User git
  Port 443
  IdentityFile ~/.ssh/id_ed25519
  IdentitiesOnly yes
  StrictHostKeyChecking accept-new
EOF

chmod 700 ~/.ssh
chmod 600 ~/.ssh/id_ed25519 ~/.ssh/config
chmod 644 ~/.ssh/id_ed25519.pub

ssh-keyscan -p 443 altssh.gitlab.com >> ~/.ssh/known_hosts
chmod 644 ~/.ssh/known_hosts
```

Copy isi pubkey ke GitLab → Profile → SSH Keys:

```bash
cat ~/.ssh/id_ed25519.pub
```

Test:

```bash
ssh -T git@gitlab-443
```

***

### 7. Siapkan source repo: mulai dari GitHub (kosongan) tapi “dibikin sama persis” dengan template ZIP

#### 7.1 Clone GitHub

```bash
cd ~
rm -rf ~/three-body-problem-main
git clone https://github.com/cikal-farid/three-body-problem-main.git
cd ~/three-body-problem-main
```

#### 7.2 Masukkan template ZIP (yang proven aman)

> Kamu tadi sudah punya ZIP. Cara paling gampang: upload ZIP ke vm-docker (scp dari laptop), taruh di `~/three-body-problem-main-main.zip`.\
> Contoh dari laptop:

```bash
# jalankan dari laptop kamu (bukan di vm)
# scp three-body-problem-main-main.zip cikal@192.168.56.42:~/
```

Di vm-docker:

```bash
cd ~
rm -rf ~/threebody-template
mkdir -p ~/threebody-template
unzip -q ~/three-body-problem-main-main.zip -d ~/threebody-template
ls -lah ~/threebody-template
```

#### 7.3 Replace isi repo GitHub dengan isi template (kecuali `.git`)

Ini yang bikin “pasti sama” seperti yang sudah running aman.

```bash
rsync -a --delete --exclude='.git' \
  ~/threebody-template/three-body-problem-main-main/ \
  ~/three-body-problem-main/
```

Verifikasi file penting ada:

```bash
cd ~/three-body-problem-main
ls -lah .gitlab-ci.yml
ls -lah deploy/k8s/base
ls -lah deploy/edge/nginx/conf.d/edge.conf
ls -lah frontend/src/App.js
```

***

### 8. Setup Edge Nginx (prod.local → NodePort K8s)

#### 8.1 Copy edge ke `/opt/threebody/edge`

```bash
sudo mkdir -p /opt/threebody/edge
sudo rsync -a --delete ~/three-body-problem-main/deploy/edge/ /opt/threebody/edge/

cd /opt/threebody/edge
sudo ln -sf docker-compose.edge.yml docker-compose.yml
sudo docker compose up -d
sudo docker ps | grep edge-nginx
```

Test nginx config:

```bash
sudo docker exec -it edge-nginx nginx -t
```

#### 8.2 Systemd `threebody-edge` (auto start saat reboot)

```bash
sudo tee /etc/systemd/system/threebody-edge.service >/dev/null <<'EOF'
[Unit]
Description=Threebody Edge Nginx (Docker Compose)
After=docker.service network-online.target
Wants=network-online.target
Requires=docker.service

[Service]
Type=oneshot
RemainAfterExit=yes
WorkingDirectory=/opt/threebody/edge
ExecStart=/usr/bin/docker compose up -d --remove-orphans
ExecStop=/usr/bin/docker compose down --remove-orphans
TimeoutStartSec=0

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl daemon-reload
sudo systemctl enable --now threebody-edge
sudo systemctl status threebody-edge --no-pager -l
```

***

### 9. Install GitLab Runner (shell) + docker permission

```bash
sudo apt-get update -y
sudo apt-get install -y curl ca-certificates

curl -L "https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh" | sudo bash
sudo apt-get install -y gitlab-runner
sudo systemctl enable --now gitlab-runner
gitlab-runner --version
```

Register runner (ambil token dari GitLab Project → Settings → CI/CD → Runners):

```bash
sudo gitlab-runner register
# executor: shell
# tags: deploy
# description: vm-docker-runner
```

Fix permission Docker untuk user `gitlab-runner`:

```bash
getent group docker || sudo groupadd docker
sudo usermod -aG docker gitlab-runner

sudo chown root:docker /var/run/docker.sock
sudo chmod 660 /var/run/docker.sock

sudo systemctl restart docker
sudo systemctl restart gitlab-runner

id gitlab-runner
sudo -u gitlab-runner docker ps
```

#### Test manual (harusnya sukses)

```bash
docker login harbor.local
# isi username/password harbor kamu
```

***

## GitLab: langkah terakhir sebelum push pertama (biar pipeline langsung aman)

### 1) Buat project GitLab BLANK (jangan initialize README)

Nama: `three-body-problem-main` (atau sesuai kamu)

### 2) Add remote + push

Di vm-docker:

```
git config --local user.name "Cikal Farid"
git config --local user.email "cikalfarid@gmail.com"
```

```bash
cd ~/three-body-problem-main
git remote -v

# ganti USERNAME kamu:
git remote add gitlab git@gitlab-443:cikalfarid/three-body-problem.git

git remote set-url gitlab git@gitlab-443:cikalfarid/three-body-problem.git
ssh -T git@gitlab-443
git push -u gitlab main

git branch -M main
git add .
git commit -m "init: sync template for pipeline"
git push -u gitlab main
```

### 3) Set GitLab CI/CD Variables (wajib)

GitLab Project → Settings → CI/CD → Variables:

**Wajib:**

* `HARBOR_USERNAME` (robot user)
* `HARBOR_PASSWORD` (robot token)
* `MYSQL_ROOT_PASSWORD`
* `MYSQL_DATABASE`
* `MYSQL_USER`
* `MYSQL_PASSWORD`
* `LARAVEL_APP_KEY` (contoh generate: `echo "base64:$(openssl rand -base64 32)"`)
* `KUBECONFIG_PROD` **Type: File** → paste isi `~/.kube/config` dari `vm-k8s`

**PENTING untuk menghindari mismatch secret:**

* `K8S_IMAGEPULL_SECRET` = `harbor-pull`

> Ini kunci biar cluster baru kamu langsung bisa pull image tanpa ImagePullBackOff.

Ambil kubeconfig dari vm-k8s:

```bash
# jalankan di vm-k8s
cat ~/.kube/config
```

***

## Setelah push: verifikasi pipeline + verifikasi aplikasi

### A) Verifikasi dari vm-k8s

```bash
kubectl get nodes -o wide
kubectl -n threebody-prod get all -o wide
kubectl -n threebody-prod get svc -o wide
```

### B) Verifikasi dari vm-docker (healthcheck sama seperti pipeline)

```bash
curl -kfsS --resolve prod.local:443:127.0.0.1 https://prod.local/ | head
curl -kfsS --resolve prod.local:443:127.0.0.1 https://prod.local/laravel/api/products | head || true
curl -kfsS --resolve prod.local:443:127.0.0.1 https://prod.local/go/api/products | head || true
```

### Pastikan API server stabil (vm-k8s) dan tidak “refused” lagi

**Di vm-k8s:**

```bash
# pastikan 6443 listen
sudo ss -lntp | grep 6443 || true

# cek kubelet & containerd
sudo systemctl is-active containerd
sudo systemctl is-active kubelet

# cek apakah ada tanda OOM / crash
dmesg -T | egrep -i "oom|killed process|out of memory" || true
df -h
free -h
```

Kalau kamu lihat RAM tinggal sedikit / disk penuh, itu kandidat kuat kenapa apiserver “refused”.

### Pastikan vm-docker selalu bisa reach 192.168.56.44:6443 (runner butuh ini)

**Di vm-docker:**

```bash
ping -c 2 192.168.56.44 || true
curl -k --connect-timeout 3 https://192.168.56.44:6443/healthz || true
ip route get 192.168.56.44 || true
```

Kalau sewaktu-waktu route hilang, biasanya beres dengan restart network service:

```bash
sudo systemctl restart NetworkManager 2>/dev/null || true
sudo systemctl restart systemd-networkd 2>/dev/null || true
sudo systemctl restart systemd-resolved 2>/dev/null || true
```

***

## One-time (biar API Laravel benar-benar “siap”): migrate + seed

> Jalankan sekali setelah deploy pertama sukses.

Di vm-k8s:

```bash
NS=threebody-prod

LARAVEL_POD=$(kubectl -n "$NS" get pod -l app=laravel -o jsonpath='{.items[0].metadata.name}')
echo "LARAVEL_POD=$LARAVEL_POD"

kubectl -n "$NS" exec -it "$LARAVEL_POD" -- php artisan migrate --force
kubectl -n "$NS" exec -it "$LARAVEL_POD" -- php artisan db:seed --force || true
```

**Jalankan di vm-k8s**

```bash
sudo journalctl -u kubelet --since "today" --no-pager | tail -n 120
kubectl get nodes -o wide
kubectl describe node vm-worker | egrep -i "Ready|NotReady|NetworkPluginNotReady|cni|runtime|error|fail" -n || true
```

Dari situ biasanya ketahuan persis: **yang restart network / apiserver** itu siapa, dan **vm-worker NotReady** karena apa.

***

## Reboot Test (yang kamu mau: matikan semua VM → hidupkan lagi → aman)

### Urutan nyalain VM yang disarankan

1. `vm-harbor`
2. `vm-k8s`
3. `vm-worker`
4. `vm-docker`

### Checklist cepat setelah reboot

#### vm-harbor

```bash
sudo systemctl status docker --no-pager
sudo systemctl status harbor --no-pager
curl -kI https://harbor.local | head
```

#### vm-k8s

```bash
sudo systemctl status containerd --no-pager
sudo systemctl status kubelet --no-pager
kubectl get nodes -o wide
```

#### vm-worker

```bash
sudo systemctl status containerd --no-pager
sudo systemctl status kubelet --no-pager
```

#### vm-docker

```bash
sudo systemctl status docker --no-pager
sudo systemctl status gitlab-runner --no-pager
sudo systemctl status threebody-edge --no-pager

curl -kfsS --resolve prod.local:443:127.0.0.1 https://prod.local/ | head
```

Kalau semua ini OK, maka:

* aplikasi aman setelah VM dimatikan/nyala
* commit baru → pipeline aman jalan lagi

***

Kalau kamu mau, langkah berikutnya yang paling “rapi” setelah ini adalah: **staging/local** (kalau kamu masih butuh `staging.local`) kita buatkan versi minimalnya juga (tanpa observability).
